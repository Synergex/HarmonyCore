.include "COERCESTRUCTURE" REPOSITORY ,structure="Coercestructure" ,end
.include "DATATABLESTR" REPOSITORY ,structure="Datatablestr" ,end
.include "DATETEBLESTR2" REPOSITORY ,structure="Dateteblestr2" ,end
.include "NULLDTARY" REPOSITORY ,structure="Nulldtary" ,end
.include "NULLDTSTR" REPOSITORY ,structure="Nulldtstr" ,end
.include "STRTEST1" REPOSITORY ,structure="Strtest1" ,end
.include "STRTEST12" REPOSITORY ,structure="Strtest12" ,end
.include "STRTEST14" REPOSITORY ,structure="Strtest14" ,end
.include "STRUCTURETEST" REPOSITORY ,structure="Structuretest" ,end
.include "BOOLEANSTR" REPOSITORY ,structure="BooleanStrR" ,end

	{xfMethod(interface="IF913",name="DateTime14",elb="TEST:if913",id="DateTime14",cType=xfType.DateTime,format=xfFormat.yyyymmddhhmiss)}
function DateTime14     ,d14
	{xfParameter(name="datetimeOf14",cType=xfType.DateTime,format=xfFormat.yyyymmddhhmiss)}
	req inout   a_dt ,d14                   ;;datetiem yyyymmddhhmmss
	endparams
;.function DateTime14
;       Arguments
;        a_dt         ,a
	
.align
	record
		chan    ,i4
		ndx     ,i4
		dt1     ,a14
		dt2	,a14
		dtr	,d14
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	dt1 = "20071030053218"
	dt2 = "20071015124519"
;;        dt1 = "00000000000000"
	;      dt2 = "00000000000000"
	a_dt = dt2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " datetime14")
;;      writes(chan, dt1)
;;      writes(chan, dt2)
;;      writes(chan, "datetime14")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	dtr = dt1
	freturn (dtr)
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="Dateyyjjj",elb="TEST:if913",id="Dateyyjjj",cType=xfType.DateTime,format=xfFormat.yyjjj)}
function Dateyyjjj      ,d5
	{xfParameter(name="Dateyyjjj",cType=xfType.DateTime,format=xfFormat.yyjjj)}
	req inout   a_dt   ,d5                     ;;datetime yyjjj
	endparams
;.function Dateyyjjj
;       Arguments
;        a_dt         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		dt1     ,a5
		dt2	,a5
		dtr	,d5
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	dt1 = "07123"
	dt2 = "07002"
	a_dt = dt2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " dateyyjjj")
;;      writes(chan, dt1)
;;      writes(chan, dt2)
;;      writes(chan, "dateyyjjj")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	dtr = dt1
	freturn (dtr)
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="Dateyymmdd",elb="TEST:if913",id="Dateyymmdd",cType=xfType.DateTime,format=xfFormat.yymmdd)}
function Dateyymmdd     ,d6
	{xfParameter(name="Dateyymmdd",cType=xfType.DateTime,format=xfFormat.yymmdd)}
	req inout   a_dt  ,d6                     ;;datetime yymmdd
	endparams
;.function Dateyymmdd
;       Arguments
;        a_dt         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		dt1     ,a6
		dt2	,a6
		dtr	,d6
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	dt1 = "071030"
	dt2 = "071015"
	a_dt = dt2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " dateyymmdd")
;;      writes(chan, dt1)
;;      writes(chan, dt2)
;;      writes(chan, "dateyymmdd")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	dtr = dt1
	freturn (dtr)
.end

; ------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="Dateyyyyjjj",elb="TEST:if913",id="Dateyyyyjjj",cType=xfType.DateTime,format=xfFormat.yyyyjjj)}
function Dateyyyyjjj    ,d7
	{xfParameter(name="Dateyyyyjjj",cType=xfType.DateTime,format=xfFormat.yyyyjjj)}
	req inout   a_dt ,d7                     ;;Datetime yyyyjjj
	endparams
;.function Dateyyyyjjj
;       Arguments
;        a_dt         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		dt1     ,a14
		dt2	,a14
		dtr	,d14
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	dt1 = "2007103"
	dt2 = "2007205"
	a_dt = dt2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " dateyyyyjjj")
;;      writes(chan, dt1)
;;      writes(chan, dt2)
;;      writes(chan, "dateyyyyjjj")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	dtr = dt1
	freturn (dtr)
.end

; ----------------------------------------------------------------------

{xfMethod(interface="IF913",name="Dateyyyymmdd",elb="TEST:if913",id="Dateyyyymmdd",cType=xfType.DateTime,format=xfFormat.yyyymmdd)}
function Dateyyyymmdd   ,d8
	{xfParameter(name="DateTimeyyyymmdd",cType=xfType.DateTime,format=xfFormat.yyyymmdd)}
	req inout   a_dt ,d8                ;;Datetime yyyymmdd
	endparams
;.function Dateyyyymmdd
;       Arguments
;        a_dt         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		dt1     ,a8
		dt2	,a8
		dtr	,d8
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
;        dt1 = "20071030"
;        dt2 = "20071015"
	dt1 = "00000000"
	dt2 = "00000000"
	a_dt = dt2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " dateyyyymmdd")
;;      writes(chan, dt1)
;;      writes(chan, dt2)
;;      writes(chan, "dateyyyymmdd")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	dtr = dt1
	freturn (dtr)
.end

; -------------------------------------------------------------------------

{xfMethod(interface="IF913",name="Time4",elb="TEST:if913",id="Time4",cType=xfType.DateTime,format=xfFormat.HHMM)}
function Time4          ,d4
	{xfParameter(name="timehhmm",cType=xfType.DateTime,format=xfFormat.HHMM)}
	req inout   a_tm    ,d4                     ;;Time HHMM
	endparams
;.function Time4
;       Arguments
;        a_tm         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		tm1     ,a4
		tm2	,a4
		tmr	,d4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	tm1 = "0532"
	tm2 = "1245"
	a_tm = tm2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " time4")
;;      writes(chan, tm1)
;;      writes(chan, tm2)
;;      writes(chan, "time4")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	tmr = tm1
	freturn (tmr)
.end

; -------------------------------------------------------------------------

{xfMethod(interface="IF913",name="Time6",elb="TEST:if913",id="Time6",cType=xfType.DateTime,format=xfFormat.hhmmss)}
function Time6          ,d6
	{xfParameter(name="timehhmmss",cType=xfType.DateTime,format=xfFormat.hhmmss)}
	req inout   a_tm  ,d6                     ;;time of hhmmss
	endparams
;.function Time6
;       Arguments
;        a_tm         ,a

.align
	record
		chan    ,i4
		ndx     ,i4
		tm1     ,a6
		tm2	,a6
		tmr	,d6
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	tm1 = "053227"
	tm2 = "124535"
	a_tm = tm2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " time6")
;;      writes(chan, tm1)
;;      writes(chan, tm2)
;;      writes(chan, "time6")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	tmr = tm1
	freturn (tmr)
.end

; ------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IDDecimal",elb="TEST:if913",id="IDDecimal",cType=xfType.decimal)}
function IDDecimal      ,d6.2
	{xfParameter(name="IDtoDecimal",cType=xfType.decimal, length=6, precision=2)}
	req inout   a_id ,d6.2                   ;;Coerce id to decimal
	endparams
;.function IDDecimal
;       Arguments
;        a_id         ,d

.align
	record
		chan    ,i4
		ndx     ,i4
		id1     ,d6.2
		id2	,d6.2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	id1 = 1234.56
	a_id = 2918.01
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IDDecimal")
;;      writes(chan, id1)
;;      writes(chan, id2)
;;      writes(chan, "IDDecimal")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (id1)
.end

; -----------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IDDouble",elb="TEST:if913",id="IDDouble",cType=xfType.double)}
function IDDouble       ,d6.2
	{xfParameter(name="IDtoDouble",cType=xfType.double, length=6, precision=2)}
	req inout   a_id  ,d6.2                   ;;Coerce id to double
	endparams
;.function IDDouble
;       Arguments
;        a_id         ,d

.align
	record
		chan    ,i4
		ndx     ,i4
		id1     ,d6.2
		id2	,d6.2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	id1 = 1234.56
	a_id = 2918.01
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IDDouble")
;;      writes(chan, id1)
;;      writes(chan, id2)
;;      writes(chan, "IDDpuble")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (id1)
.end

; --------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IDFloat",elb="TEST:if913",id="IDFloat",cType=xfType.float)}
function IDFloat        ,d6.2
	{xfParameter(name="IDtoFloat",cType=xfType.float, length=6, precision=2)}
	req inout   a_id   ,d6.2                  ;;coerce id to float
	endparams
;.function IDFloat
;       Arguments
;        a_id         ,d

.align
	record
		chan    ,i4
		ndx     ,i4
		id1     ,d6.2
		id2	,d6.2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	id1 = 1234.56
	a_id = 2918.01
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IDFloat")
;;      writes(chan, id1)
;;      writes(chan, id2)
;;      writes(chan, "IDFloat")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (id1)
.end

; -------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntBool",elb="TEST:if913",id="IntBool",cType=xfType.Boolean)}
function IntBool        ,i1
	{xfParameter(name="IntToBool",cType=xfType.Boolean)}
	req inout   a_i   ,i1                     ;;Coerce int to boolean
	endparams
;.function IntBool
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i1
		i2	,i1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 1
	i2 = 2
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntBool")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntBool")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; -----------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntByte",elb="TEST:if913",id="IntByte",cType=xfType.byte)}
function IntByte        ,i1
	{xfParameter(name="IntToByte",cType=xfType.byte)}
	req inout   a_i   ,i1                     ;;Coerce Int to byte
	endparams
;.function IntByte
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i1
		i2	,i1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 1
	i2 = 2
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntByte")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntByte")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; ---------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntInt",elb="TEST:if913",id="IntInt",cType=xfType.int)}
function IntInt         ,i4
	{xfParameter(name="IntToInt",cType=xfType.int)}
	req inout   a_i    ,i4                     ;;Coerce int to int
	endparams
;.function IntInt
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i4
		i2	,i4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 1234
	i2 = 5678
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntInt")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntInt")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; --------------------------------------------------------------

{xfMethod(interface="IF913",name="IntLong",elb="TEST:if913",id="IntLong",cType=xfType.long, length=8)}
function IntLong        ,i
	{xfParameter(name="IntToLong",cType=xfType.long, length=8)}
	req inout   a_i   ,i                     ;;Coerce int to long
	endparams
;.function IntLong
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i8
		i2	,i8
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 12345678
	i2 = 23456789
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntLong")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntLong")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; --------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntSbyte",elb="TEST:if913",id="IntSbyte",cType=xfType.sbyte)}
function IntSbyte       ,i1
	{xfParameter(name="IntToSbyte",cType=xfType.sbyte)}
	req inout   a_i  ,i1                     ;;Coerce int to sbyte
	endparams
;.function IntSbyte
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i1
		i2	,i1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 1
	i2 = 2
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntSbyte")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntSbyte")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; -------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntShort",elb="TEST:if913",id="IntShort",cType=xfType.short)}
function IntShort       ,i2
	{xfParameter(name="IntToShort",cType=xfType.short)}
	req inout   a_i  ,i2                     ;;Coerce int to short
	endparams
;.function IntShort
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i2
		i2	,i2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 12
	i2 = 34
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntShort")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntShort")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; ----------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntUint",elb="TEST:if913",id="IntUint",cType=xfType.uint)}
function IntUint        ,i4
	{xfParameter(name="IntToUint",cType=xfType.uint)}
	req inout   a_i   ,i4                     ;;Coerce int to uint
	endparams
;.function IntUint
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i4
		i2	,i4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 1234
	i2 = 5678
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntUint")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntUint")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; ------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntUlong",elb="TEST:if913",id="IntUlong",cType=xfType.ulong, length=8)}
function IntUlong       ,i
	{xfParameter(name="IntToUlong",cType=xfType.ulong, length=8)}
	req inout   a_i  ,i                     ;;Coerce int to ulong
	endparams
;.function IntUlong
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i8
		i2	,i8
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 12345678
	i2 = 23456789
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntUlong")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntUlong")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; ------------------------------------------------------------------------

{xfMethod(interface="IF913",name="IntUshort",elb="TEST:if913",id="IntUshort",cType=xfType.ushort)}
function IntUshort      ,i2
	{xfParameter(name="IntToUshort",cType=xfType.ushort)}
	req inout   a_i ,i2                     ;;Coerce int to ushort
	endparams
;.function IntUshort
;       Arguments
;        a_i         ,i
	
.align
	record
		chan    ,i4
		ndx     ,i4
		i1      ,i2
		i2	,i2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	i1 = 12
	i2 = 34
	a_i = i2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntUshort")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntUshort")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (i1)
.end

; -------------------------------------------------------------------------

{xfMethod(interface="IF913",name="TrueString",elb="TEST:if913",id="TrueString")}
function TrueString     ,string
	{xfParameter(name="astring")}
	req inout   a_s     ,string              ;;System.string
	endparams
;.function TrueString,	@System.String
;       Arguments
;        required a_s         ,@System.String

.align
	record
		chan    ,i4
		ndx     ,i4
		s1      ,@System.String
		s2	,@System.String
		s3	,@System.String
		al	,a20
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	s1 = "Hello there" ; new String("Hello there")
;;	 s2 = new System.String("How are you")
	s2 = "" ; new System.String("")
	s3 = a_s
	al = "It worked!"
	writes(chan, "    ")
	writes(chan, " ********************************")
	writes(chan, " TrueString")
	writes(chan, s1)
	writes(chan, s2)
	writes(chan, s3)
	writes(chan, al)
	a_s = S2
	writes(chan, a_s)
	writes(chan, "TrueString")
	writes(chan, " ********************************")
	writes(chan, "  u   ")
	close (chan)
	freturn (s1)
.end

; ---------------------------------------------------------------------

{xfMethod(interface="IF913",name="TrueStringParmOnly",elb="TEST:if913",id="TrueStringParmOnly")}
subroutine TrueStringParmOnly
	{xfParameter(name="SysStr")}
	req inout   a_s      ,string               ;;
	endparams
;.subroutine TrueStringParmOnly
;       Arguments
;	required a_s         ,@System.String

.align
	record
		chan    ,i4
		ndx     ,i4
		s1      ,@System.String
		s2	,@System.String
		s3	,@System.String
		al	,a20
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	s1 = "Hello there" ; new System.String("Hello there")
	s2 = "How are you" ; new System.String("How are you")
	s3 = a_s
	al = "It worked!"
	writes(chan, "    ")
	writes(chan, " ********************************")
	writes(chan, " TrueStringParmOnly")
	writes(chan, s1)
	writes(chan, s2)
	writes(chan, " **** a_s ***")
	writes(chan, a_s)
	writes(chan, s3)
	writes(chan, al)
	a_s = S2
	writes(chan, a_s)
	writes(chan, "TrueStringParmOnly")
	writes(chan, " ********************************")
	writes(chan, "    ")
	close (chan)
	xreturn
.end

.subroutine StringTestIn
;       Arguments
	required in a_s         ,@System.String

.align
	record
		chan    ,i4
		ndx     ,i4
		s1      ,@System.String
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	s1 = "Hello there how are you?" ;  new System.String("Hello there how are you?")
	writes(chan, "    ")
	writes(chan, " ********************************")
	writes(chan, " StringTestIn")
	writes(chan, s1)
	writes(chan, " **** a_s ***")
	writes(chan, a_s)
	writes(chan, " ********************************")
	writes(chan, "    ")
	close (chan)
	xreturn
.end

.subroutine StringTestOut
;       Arguments
	required out a_s         ,@System.String

.align
	record
		chan    ,i4
		ndx     ,i4
		s1      ,@System.String
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	s1 = "Hello there how are you?" ; new System.String("Hello there how are you?")
	a_s = s1
	writes(chan, "    ")
	writes(chan, " ********************************")
	writes(chan, " StringTestOut")
	writes(chan, s1)
	writes(chan, " **** a_s ***")
	writes(chan, a_s)
	writes(chan, " ********************************")
	writes(chan, "    ")
	close (chan)
	xreturn
.end

.subroutine StringTestInOut
;       Arguments
	required inout a_s         ,@System.String

.align
	record
		chan    ,i4
		ndx     ,i4
		s1      ,@System.String
		s2	,@System.String
		s3	,@System.String
		al	,a20
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	s1 = "Hello there" ; new System.String("Hello there")
	s2 = "How are you?" ; new System.String("How are you?")
	s3 = a_s
	al = "It worked!"
	writes(chan, "    ")
	writes(chan, " ********************************")
	writes(chan, " StringTestInOut")
	writes(chan, s1)
	writes(chan, s2)
	writes(chan, " **** a_s ***")
	writes(chan, a_s)
	writes(chan, s3)
	writes(chan, al)
	a_s = S2
	writes(chan, a_s)
	writes(chan, "StringTestInOut")
	writes(chan, " ********************************")
	writes(chan, "    ")
	close (chan)
	xreturn
.end


; ------  Decimal Coerce tests --------------------------

{xfMethod(interface="IF913",name="DecDec",elb="TEST:if913",id="DecDec",cType=xfType.long)}
function DecDec         ,d12
	{xfParameter(name="DecToDec",cType=xfType.long)}
	req inout   a_d    ,d16                    ;;coerced dec to dec
	endparams
;.function DecDec
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d12
		d2	,d12
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 123456789012
	d2 = 234567890123
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecDec")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecDec")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; ----------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecBool",elb="TEST:if913",id="DecBool",cType=xfType.Boolean)}
function DecBool        ,d1
	{xfParameter(name="DecToBool",cType=xfType.Boolean)}
	req inout   a_d   ,d1                     ;;Coerce dec to boolean
	endparams
;.function DecBool
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d1
		d2	,d1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 1
	d2 = 2
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecBool")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecBool")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; --------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecByte",elb="TEST:if913",id="DecByte",cType=xfType.byte)}
function DecByte        ,d1
	{xfParameter(name="DecToByte",cType=xfType.byte)}
	req inout   a_d   ,d1                     ;;coerce dec to byte
	endparams
;.function DecByte
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d1
		d2	,d1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 1
	d2 = 2
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecByte")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecByte")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; ------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecInt",elb="TEST:if913",id="DecInt",cType=xfType.int)}
function DecInt         ,d4
	{xfParameter(name="DecToInt",cType=xfType.int)}
	req inout   a_d    ,d4                     ;;coerce dec to int
	endparams
;.function DecInt
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d4
		d2	,d4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 1234
	d2 = 5678
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecInt")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecInt")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; --------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecLong",elb="TEST:if913",id="DecLong",cType=xfType.long)}
function DecLong        ,d18
	{xfParameter(name="DecToLong",cType=xfType.long)}
	req inout   a_d   ,d18                    ;;coerce dec to long
	endparams
;.function DecLong
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d18
		d2	,d18
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 12345678
	d2 = 23456789
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecLong")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecLong")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; ----------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecSbyte",elb="TEST:if913",id="DecSbyte",cType=xfType.sbyte)}
function DecSbyte       ,d1
	{xfParameter(name="DecToSbyte",cType=xfType.sbyte)}
	req inout   a_d  ,d1                     ;;coerce dec to sbyte
	endparams
;.function DecSbyte
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d1
		d2	,d1
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 1
	d2 = 2
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecSbyte")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecSbyte")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; -------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecShort",elb="TEST:if913",id="DecShort",cType=xfType.short)}
function DecShort       ,d2
	{xfParameter(name="DecToShort",cType=xfType.short)}
	req inout   a_d  ,d2                     ;;coerce dec to short
	endparams
;.function DecShort
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d2
		d2	,d2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 12
	d2 = 34
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecShort")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecShort")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; -------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecUint",elb="TEST:if913",id="DecUint",cType=xfType.uint)}
function DecUint        ,d4
	{xfParameter(name="DecToUint",cType=xfType.uint)}
	req inout   a_d   ,d4                     ;;coerce dec to uint
	endparams
;.function DecUint
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d4
		d2	,d4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 1234
	d2 = 5678
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecUint")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, "DecUint")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; --------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecUlong",elb="TEST:if913",id="DecUlong",cType=xfType.ulong)}
function DecUlong       ,d18
	{xfParameter(name="DecToUlong",cType=xfType.ulong)}
	req inout   a_d  ,d18                    ;;coerce dec to ulong
	endparams
;.function DecUlong
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d8
		d2	,d8
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 12345678
	d2 = 23456789
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecUlong")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, " DecUlong")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; ----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DecUshort",elb="TEST:if913",id="DecUshort",cType=xfType.ushort)}
function DecUshort      ,d2
	{xfParameter(name="DecToUshort",cType=xfType.ushort)}
	req inout   a_d ,d2                     ;;coerce dec to ushort
	endparams
;.function DecUshort
;       Arguments
;        a_d         ,d
	
.align
	record
		chan    ,i4
		ndx     ,i4
		d1      ,d2
		d2	,d2
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	d1 = 12
	d2 = 34
	a_d = d2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " DecUshort")
;;      writes(chan, d1)
;;      writes(chan, d2)
;;      writes(chan, " DecUshort")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (d1)
.end

; ---------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofAlphaOut",elb="TEST:if913",id="ALofAlphaOut")}
subroutine ALofAlphaOut
	{xfParameter(name="AryLstAlpha",collectionType=xfCollectType.alpha,length=25)}
	req out     a_al ,@System.Collections.ArrayList ;;AL of out alpha size 25
	endparams
;.subroutine AlofAlphaOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al	,[*]a

.align
	record
		chan    ,i4
		i	,i4
		ct 	,i4
		ast     ,a25
		d2	,d2
		abox	,@a
		ibox	,@i
		sA 	,[5]a5

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	ast = "Hello"
	arylst = new System.Collections.ArrayList()
	for i from 0 thru 4
	begin
		ct = i + 1
		ast = "HiThere-" + %string(ct)
		abox = (@a)ast
		arylst.add(abox)
		sA[i + 1] = ast
		writes(chan, ast)
		writes(chan, abox)
	end
	a_al = arylst
;	a_al = sA

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofAlphas",elb="TEST:if913",id="ALofAlphas")}
subroutine ALofAlphas
	{xfParameter(name="AlphaArrayList",collectionType=xfCollectType.alpha,length=25)}
	req in      a_al ,@System.Collections.ArrayList ;;An ArrayList of a25 alphas
	endparams
;.subroutine ALofAlphas
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		d2	,d2
		abox	,@a
		bbox	,@a

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	ast = " "
	arylst = a_al
	for i from 0 thru 4
	begin
		bbox = arylst[i]
		abox = a_al[i]
		writes(chan,bbox)
		writes(chan,abox)
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofDecimalOut",elb="TEST:if913",id="ALofDecimalOut")}
subroutine ALofDecimalOut
	{xfParameter(name="DecALOut",collectionType=xfCollectType.decimal,length=7)}
	req out     a_al    ,@System.Collections.ArrayList ;;AryLst of dec size 7 out
	endparams
;.subroutine AlofDecimalOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d18
		dbox	,@d

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	;;      dv = 200000000100000
	dv = 20000
	arylst = new System.Collections.ArrayList()
	for i from 0 thru 4
	begin
		dv += i + 1
		dbox = (@d)dv
		arylst.add(dbox)
		writes(chan, %string(dbox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ---------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofDecimal",elb="TEST:if913",id="ALofDecimal")}
subroutine ALofDecimal
	{xfParameter(name="DecimalArrayList",collectionType=xfCollectType.decimal,length=10)}
	req in      a_al ,@System.Collections.ArrayList ;;An ArrayList of d10 decimals
	endparams
;.subroutine AlofDecimal
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al	,[*]d
	
.align
	record
		chan    ,i4
		i	,i4
		ct	,i4
		dv	,d18
		abox	,@d
		dbox	,@d
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		abox = a_al[i]
		dv = dbox
		writes(chan, %string(dbox))
		writes(chan, %string(abox))
		writes(chan, %string(dv))
	end
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofImpDecOut",elb="TEST:if913",id="ALofImpDecOut")}
subroutine ALofImpDecOut
	{xfParameter(name="IDALout",collectionType=xfCollectType.decimal,length=7, precision=2)}
	req out     a_al     ,@System.Collections.ArrayList ;;arylst of id 7.2 out
	endparams
;.subroutine AlofImpDecOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d7.2
		dbox	,@id

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	dv = 10000.23
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		dv += i
		dbox = (@id)dv
		arylst.add(dbox)
	end
	a_al = arylst

;;      writes(chan, "    ")
;;      close (chan)
	xreturn 
.end

; --------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofImpDec",elb="TEST:if913",id="ALofImpDec")}
subroutine ALofImpDec
	{xfParameter(name="IDArrayList",collectionType=xfCollectType.decimal,length=7, precision=2)}
	req in      a_al ,@System.Collections.ArrayList ;;An arraylist of ID 7.2
	endparams
;.subroutine AlofImpDec
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	 a_al	,[*]d.
.align
	record
		chan    ,i4
		i	,i4
		dd	,d28.10
		dv	,d28.10
		abox	,@id
		dbox	,@id
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	dd = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		dd = dbox
		abox = a_al[i]
		writes(chan, %string(dd))
		writes(chan, %string(abox))
		writes(chan, %string(dbox))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ----------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofIntOut",elb="TEST:if913",id="ALofIntOut")}
subroutine ALofIntOut
	{xfParameter(name="IntALOut",collectionType=xfCollectType.integer,length=4)}
	req out     a_al    ,@System.Collections.ArrayList ;;arylst of i4 out
	endparams
;.subroutine AlofIntOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		int	,i4
		ibox	,@i

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	int = 10002
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		int += i
		ibox = (@i)int
		arylst.add(ibox)
		writes(chan, %string(ibox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofInt",elb="TEST:if913",id="ALofInt")}
subroutine ALofInt
	{xfParameter(name="IntArrayList",collectionType=xfCollectType.integer,length=4)}
	req in      a_al ,@System.Collections.ArrayList ;;An arraylist of i4
	endparams
;.subroutine AlofInt
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al 	,[*]i

.align
	record
		chan    ,i4
		i	,i4
		int	,i4
		abox	,@i
		ibox	,@i
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	int = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		ibox = arylst[i]
		int = (i)ibox
		abox = a_al[i]
		writes(chan, %string(ibox))
		writes(chan, %string(int))
		writes(chan, %string(abox))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofStringOut",elb="TEST:if913",id="ALofStringOut")}
subroutine ALofStringOut
	{xfParameter(name="StringALOut",collectionType=xfCollectType.string)}
	req out     a_al ,@System.Collections.ArrayList ;;arylst string out
	endparams
;.subroutine AlofStringOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		str	,@System.String
		abox	,@a

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop"  ; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		arylst.add(str)
;;		abox = str;
		writes(chan, str)
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; --------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofString",elb="TEST:if913",id="ALofString")}
subroutine ALofString
	{xfParameter(name="StringArrayList",collectionType=xfCollectType.string)}
	req in      a_al ,@System.Collections.ArrayList ;;An arraylist of strings
	endparams
;.subroutine AlofString
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al	,[*]a


.align
	record
		chan    ,i4
		i	,i4
		cnt	,i4
		astr	,a25
		str	,@System.String
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
;	arylst = a_al
	cnt = a_al.Count
	if (cnt .gt. 0)
	begin
		for i from 0 thru 4
		begin
;			str = (System.String)arylst[i]
;			astr = (a)str
;    			astr = a_al[i]
			str = (System.String)a_al[i]
			writes(chan, str)
		end
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofStrOut",elb="TEST:if913",id="ALofStrOut")}
subroutine ALofStrOut
	{xfParameter(name="STRUCTURETEST",structure="Structuretest",collectionType=xfCollectType.structure)}
	req out     a_al ,@System.Collections.ArrayList ;;Str arylist of out
	endparams
;.subroutine AlofStrOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList

	record aStrTst
		PARM1 ,A25   ; (1,25)
		PARM2 ,D8    ; (26,33)
		PARM3 ,D8.3  ; (34,41)

	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		str	,@System.String
		abox	,@a
		aSt1	,Structuretest
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop" ; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		clear aStrTst
		aStrTst.parm1 = "Sam One"
		aStrTst.parm2 = 453200 + I
		aStrTst.parm3 = 1000.23 + i
.ifdef DBLNET
		aSt1 = aStrTst
		arylst.add(aSt1)
.else
		abox = (@a)aStrTst
		arylst.add(abox)
.endc
		writes(chan, aStrTst)
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofStr",elb="TEST:if913",id="ALofStr")}
subroutine ALofStr
	{xfParameter(name="STRUCTURETEST",structure="Structuretest",collectionType=xfCollectType.structure)}
	req in      a_al ,@System.Collections.ArrayList ;;An arraylist of structuretest of size 41
	endparams
;.subroutine AlofStr
;       Arguments
;        required a_al         ,@System.Collections.ArrayList;
;;	a_al	,[*]a

	record aStrTst
		PARM1 ,A25   ; (1,25)
		PARM2 ,D8    ; (26,33)
		PARM3 ,D8.3  ; (34,41)
	
.align
	record
		chan    ,i4
		i	,i4
		astr	,a25
		abox	,@a
		aSt1	,Structuretest
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	arylst = a_al
	for i from 0 thru 4
	begin
		aSt1 = (Structuretest)arylst[i]
		aStrTst = aSt1
;		abox = arylst[i]
;		aStrTst = (a)abox
;    		aStrTst = a_al[i]
		writes(chan, aStrTst)
		writes(chan, aStrTst.parm1)
		writes(chan, %string(aStrTst.parm2))
		writes(chan, %string(aStrTst.parm3))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ---------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDateTimeOut",elb="TEST:if913",id="AlofDateTimeOut")}
subroutine AlofDateTimeOut
	{xfParameter(name="DateTimeOut",collectionType=xfCollectType.decimal,length=8,cType=xfType.DateTime,format=xfFormat.yyyymmdd)}
	req out     a_al ,@System.Collections.ArrayList ;;Arraylist of Dat4eTime YYYYMMDD to dec
	endparams
;.subroutine AlofDateTimeOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d8
		dbox	,@d

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	dv = 20070400
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		dv += i
		dbox = (@d)dv
		arylst.add(dbox)
		writes(chan, %string(dbox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDateTime",elb="TEST:if913",id="AlofDateTime")}
subroutine AlofDateTime
	{xfParameter(name="DateTimeIn",collectionType=xfCollectType.decimal,length=8,cType=xfType.DateTime,format=xfFormat.yyyymmdd)}
	req in      a_al  ,@System.Collections.ArrayList ;;ArrayList of Decimal to DateTime YYYYMMDD
	endparams
;.subroutine AlofDateTime
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		dv	,d8
		abox	,@d
		dbox	,@d
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		abox = a_al[i]
		dv = dbox
		writes(chan, %string(dbox))
		writes(chan, %string(abox))
		writes(chan, %string(dv))
	end
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofIntBoolOut",elb="TEST:if913",id="AlofIntBoolOut")}
subroutine AlofIntBoolOut
	{xfParameter(name="BoolInt",collectionType=xfCollectType.integer,length=1,cType=xfType.Boolean)}
	req out     a_al     ,@System.Collections.ArrayList ;;Arraylist of int 1 coerced to boolean
	endparams
;.subroutine AlofIntBoolOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		int	,i1
		ibox	,@i

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	int = 1
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		int = 0
		if ((i .eq. 2) .or. (i .eq. 4))
		begin
			int = 1;
		end
		ibox = (@i)int
		arylst.add(ibox)
		writes(chan, %string(ibox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofintBool",elb="TEST:if913",id="AlofIntBool")}
subroutine AlofintBool
	{xfParameter(name="BoolInt",collectionType=xfCollectType.integer,length=1,cType=xfType.Boolean)}
	req in      a_al     ,@System.Collections.ArrayList ;;ArrayList of int 1 as a boolean
	endparams
;.subroutine AlofIntBool
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al 	,[*]i

.align
	record
		chan    ,i4
		i	,i1
		int	,i1
		abox	,@i
		ibox	,@i
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	int = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		ibox = arylst[i]
		int = (i)ibox
		abox = a_al[i]
		writes(chan, %string(ibox))
		writes(chan, %string(int))
		writes(chan, %string(abox))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDecLongOut",elb="TEST:if913",id="AlofDecLongOut")}
subroutine AlofDecLongOut
	{xfParameter(name="DecLong",collectionType=xfCollectType.decimal,length=18,cType=xfType.long)}
	req out     a_al     ,@System.Collections.ArrayList ;;ArrayList of dec 18 to long
	endparams
;.subroutine AlofDecLongOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d18
		dbox	,@d

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	dv = 2003004001005000
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		dv += i
		dbox = (@d)dv
		arylst.add(dbox)
		writes(chan, %string(dbox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDeclong",elb="TEST:if913",id="AlofDecLong")}
subroutine AlofDeclong
	{xfParameter(name="DecLong",collectionType=xfCollectType.decimal,length=18,cType=xfType.long)}
	req in      a_al     ,@System.Collections.ArrayList ;;ArrayList of Dec 18 to Long
	endparams
;.subroutine AlofDecLong
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al	,[*]d
	
.align
	record
		chan    ,i4
		i	,i4
		dv	,d18
		abox	,@d
		dbox	,@d
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		abox = a_al[i]
		dv = dbox
		writes(chan, %string(dbox))
		writes(chan, %string(abox))
		writes(chan, %string(dv))
	end
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ---------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDecShortOut",elb="TEST:if913",id="AlofDecShortOut")}
subroutine AlofDecShortOut
	{xfParameter(name="DecShort",collectionType=xfCollectType.decimal,length=4,cType=xfType.short)}
	req out     a_al    ,@System.Collections.ArrayList ;;Arraylist of dec 4 to short out
	endparams
;.subroutine AlofDecShortOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d4
		dbox	,@d

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	dv = 200
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		dv += i
		dbox = (@d)dv
		arylst.add(dbox)
		writes(chan, %string(dbox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; --------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofDecShort",elb="TEST:if913",id="AlofDecShort")}
subroutine AlofDecShort
	{xfParameter(name="DecShort",collectionType=xfCollectType.decimal,length=4,cType=xfType.short)}
	req in      a_al    ,@System.Collections.ArrayList ;;Arraylist of dec 4 to short
	endparams
;.subroutine AlofDecShort
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	a_al	,[*]d
	
.align
	record
		chan    ,i4
		i	,i4
		dv	,d4
		abox	,@d
		dbox	,@d
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		abox = a_al[i]
		dv = dbox
		writes(chan, %string(dbox))
		writes(chan, %string(abox))
		writes(chan, %string(dv))
	end
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofIDDoubleOut",elb="TEST:if913",id="AlofIDDoubleOut")}
subroutine AlofIDDoubleOut
	{xfParameter(name="IDDouble",collectionType=xfCollectType.decimal,length=12,precision=2,cType=xfType.double)}
	req out     a_al    ,@System.Collections.ArrayList ;;ArrayList of ID 12.2 to double
	endparams
;.subroutine AlofIDDoubleOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a25
		dv	,d12.2
		dbox	,@id

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	dv = 100200300.23
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		dv += i
		dbox = (@id)dv
		arylst.add(dbox)
		writes(chan, %string(dbox))
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ----------------------------------------------------------------------------

{xfMethod(interface="IF913",name="AlofIDDouble",elb="TEST:if913",id="AlofIDDouble")}
subroutine AlofIDDouble
	{xfParameter(name="IDDouble",collectionType=xfCollectType.decimal,length=12,precision=2,cType=xfType.double)}
	req in      a_al    ,@System.Collections.ArrayList ;;ArrayList of ID 12.2 to double
	endparams
;.subroutine AlofIDDouble
;       Arguments
;        required a_al         ,@System.Collections.ArrayList
;	 a_al	,[*]d.
.align
	record
		chan    ,i4
		i	,i4
		dd	,d28.10
		dv	,d28.10
		abox	,@id
		dbox	,@id
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	dv = 0
	dd = 0
	arylst = a_al
	for i from 0 thru 4
	begin
		dbox = arylst[i]
		dd = dbox
		abox = a_al[i]
		writes(chan, %string(dd))
		writes(chan, %string(abox))
		writes(chan, %string(dbox))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ----------------------------------------------------------------------

{xfMethod(interface="IF913",name="DTCollection",elb="TEST:if913",id="DTCollection")}
subroutine DTCollection
	{xfParameter(name="DATETEBLESTR2",structure="Dateteblestr2",collectionType=xfCollectType.structure,dataTable=true)}
	req out     mhout ,D_HANDLE             ;;DataTable of structuretest record as a collection
	endparams
;.subroutine DTCollection
; mhout, n

	record aStrTst                                                     
		ALPHAFLD1      ,A10   ; (1,10)                                                
		DEC4FLD        ,D4    ; (11,14)                                               
		group GROUPFLD ,A     ; (15,39)                                               
			GPALPHA      ,A20   ;   (1,20)                                              
			GPDEC        ,D5    ;   (21,25)                                             
		endgroup              ; end group GROUPFLD                                    
		IDFILED        ,D7.2  ; (40,46)                                               

	structure Abd
		Abdy,	a1

.align
	record
		i, 		i4
		cur,		i4
		memsize,	i4
		numrecs,	i4
		recsize,	i4
		chan,		i4

.proc
	recsize = 46;
	numrecs = 5;
	memsize = recsize * numrecs
  
	mhout = %mem_proc(DM_RESIZ,memsize,mhout)
	chan = 219
	open(chan, a, "TEST:if913.log")
	cur = 1
	for i from 1 thru numrecs
	begin
		clear aStrTst
		aStrTst.alphafld1 = "Data " + %string(i)
		aStrTst.dec4fld = 1000 + i
		aStrTst.idfiled = 100.31 + i
		aStrTst.groupfld.gpalpha = "Hello"
		aStrTst.groupfld.gpdec = 100 + i
		writes(chan, aStrTst)
		^m(Abd.Abdy(cur:recsize),mhout) = aStrTst
		cur = cur + recsize
	end

	writes(chan,"  ")
	close (chan)
	xreturn

.end

; --------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DTALStructureOut",elb="TEST:if913",id="DTALStructureOut")}
subroutine DTALStructureOut
	{xfParameter(name="DATATABLESTR",structure="Datatablestr",collectionType=xfCollectType.structure,dataTable=true)}
	req out     a_al ,@System.Collections.ArrayList ;;ArrayList as a Datatable of structures out
	endparams
;.subroutine DTALStructureOut
;       Arguments
;        required a_al         ,@System.Collections.ArrayList

	record aStrTst2                                                     
		ALPHAFLD1      ,A10   ; (1,10)                                                
		DEC4FLD        ,D4    ; (11,14)                                               
		group GROUPFLD ,A     ; (15,39)                                               
			GPALPHA      ,A20   ;   (1,20)                                              
			GPDEC        ,D5    ;   (21,25)                                             
		endgroup              ; end group GROUPFLD                                    
		IDFILED        ,D7.2  ; (40,46)                                               

	record   aStrTst                                                    
		ACCOUNTNUMBER ,D6    ; (1,6) Account number                                   
		NAME          ,A25   ; (7,31) name                                            
		AMOUNT        ,D8.2  ; (32,39)                                                
		QTY           ,D5    ; (40,44)                                                
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a46
		str	,@System.String
		abox	,@a
		aStr1	,datatablestr
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop" ; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		clear aStrTst
		aStrTst.NAME = "Data " + %string(i)
		aStrTst.ACCOUNTNUMBER = 1000 + i
		aStrTst.AMOUNT = 12000.31 + i
		aStrTst.QTY = 100 + i
.ifdef DBLNET
		aStr1 = aStrTst 
		arylst.add(aStr1)
.else
		abox = (@a)aStrTst
		arylst.add(abox)
.endc
		writes(chan, aStrTst)
	end
	a_al = arylst
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DTALStructureIn",elb="TEST:if913",id="DTArrayListIn")}
subroutine DTALStructureIn
	{xfParameter(name="DATATABLESTR",structure="Datatablestr",collectionType=xfCollectType.structure,dataTable=true)}
	req in      a_al ,@System.Collections.ArrayList ;;
	endparams
;.subroutine DTALStructureIn
;       Arguments
;        required a_al         ,@System.Collections.ArrayList;

	record   aStrTst                                                    
		ACCOUNTNUMBER ,D6    ; (1,6) Account number                                   
		NAME          ,A25   ; (7,31) name                                            
		AMOUNT        ,D8.2  ; (32,39)                                                
		QTY           ,D5    ; (40,44)                                                
	
  
.align
	record
		chan    ,i4
		i	,i4
		astr	,a25
		abox	,@a
		aSt1	,datatablestr
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	writes(chan, " In DTALStructureIn")
	arylst = a_al
	for i from 0 thru 4
	begin
		aSt1 = (datatablestr)arylst[i]
		aStrTst = aSt1
;		abox = arylst[i]
;		aStrTst = (a)abox
;    		aStrTst = a_al[i]
	
		writes(chan, aStrTst)
		writes(chan, aStrTst.NAME)
		writes(chan, %string(aStrTst.AMOUNT))
		writes(chan, %string(aStrTst.ACCOUNTNUMBER))
		writes(chan, %string(aStrTst.QTY))
	end



	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------

; Coerced types within a structure

{xfMethod(interface="IF913",name="CoercedStructure",elb="TEST:if913",id="CoercedStructure")}
subroutine CoercedStructure
	{xfParameter(name="COERCESTRUCTURE",structure="strCoercestructure")}
	req inout   a_str1 ,strCoercestructure    ;;Coerced data types within a structure
	endparams
;.subroutine CoercedStructure
;       Arguments
;        a_str1          ,a

;.include "coercestructure.rec"
	.include "coercestructure" repository, record="coerced", end

.align
	record
		chan    ,i4
		ndx     ,i4
		msg     ,a30

.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	writes(chan, " In Coerce Structure")
	coerced =  a_str1
	writes(chan, coerced)
	writes(chan, %string(decint))
	writes(chan, %string(decbool))
	writes(chan, %string(decbyte))
	writes(chan, %string(decshort))
	writes(chan, %string(declong))
	writes(chan, %string(decsbyte))
	writes(chan, %string(decuint))
	writes(chan, %string(decushort))
	writes(chan, %string(deculong))
	writes(chan, %string(decdatetime))
	writes(chan, %string(nulldatetime))
	writes(chan, %string(iddecimal))
	writes(chan, %string(iddouble))
	writes(chan, %string(idfloat))
	writes(chan, %string(intint))
	writes(chan, %string(intbool))
	writes(chan, %string(intbyte))
	writes(chan, %string(intshort))
	writes(chan, %string(intlong))
	writes(chan, %string(intsbyte))
	writes(chan, %string(intuint))
	writes(chan, %string(intushort))
	writes(chan, %string(intulong))

	decint = 12345
	decbool = 1
	decbyte = 3
	decshort  = 45
	declong = 123456789
	decsbyte = 7
	decuint = 54321
	decushort = 56
	deculong = 7654321
	decdatetime = 20071125
	nulldatetime = 0
	iddecimal = 12345.67
	iddouble = 567891.45
	idfloat = 345678.91
	intint = 12345
	intbool = 1
	intbyte = 3
	intshort  = 45
	intlong = 123456789
	intsbyte = 7
	intuint = 54321
	intushort = 56
	intulong = 7654321
	writes(chan, " Out Coerce Structure")
	writes(chan, coerced)
	writes(chan, %string(decint))
	writes(chan, %string(decbool))
	writes(chan, %string(decbyte))
	writes(chan, %string(decshort))
	writes(chan, %string(declong))
	writes(chan, %string(decsbyte))
	writes(chan, %string(decuint))
	writes(chan, %string(decushort))
	writes(chan, %string(deculong))
	writes(chan, %string(decdatetime))
	writes(chan, %string(nulldatetime))
	writes(chan, %string(iddecimal))
	writes(chan, %string(iddouble))
	writes(chan, %string(idfloat))
	writes(chan, %string(intint))
	writes(chan, %string(intbool))
	writes(chan, %string(intbyte))
	writes(chan, %string(intshort))
	writes(chan, %string(intlong))
	writes(chan, %string(intsbyte))
	writes(chan, %string(intuint))
	writes(chan, %string(intushort))
	writes(chan, %string(intulong))

	a_str1 = coerced
	close (chan)
	xreturn
.end

; ----------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DTGroupStructs",elb="TEST:if913",id="DTGroupStructs")}
subroutine DTGroupStructs
	{xfParameter(name="STRTEST14",structure="Strtest14",collectionType=xfCollectType.structure,dataTable=true)}
	req out     a_al   ,@System.Collections.ArrayList ;;
	endparams
;.subroutine DTGroupStructs
;       Arguments
;        required a_al         ,@System.Collections.ArrayList

	record strtest14
		group RECKEY   ,A     ; (1,10) The record key
			COMPANY_CODE ,D3    ;   (1,3) The company code
			PROD_ID      ,D7    ;   (4,10) Product ID number
		endgroup              ; end group RECKEY
		PROD_NAME      ,A30   ; (11,40)
		COST           ,D8.2  ; (41,48) Item cost
		group LOC_GRP  ,A     ; (49,62) Location group
			WHRS         ,D2    ;   (1,2) warerhouse number
			group ILEGRP ,A     ;   (3,8)
				ROW        ,D3    ;     (1,3) row it's on
				SHELF      ,D3    ;     (4,6) shelf level
			endgroup            ;   end group ILEGRP
			COUNT        ,D6    ;   (9,14)
		endgroup              ; end group LOC_GRP
		COMMENT        ,A50   ; (63,112) comments
	
.align
	record
		chan    ,i4
		i	,i4
		ast     ,a46
		str	,@System.String
		abox	,@a
		aStr1	,strtest14

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop"; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		clear strtest14
		strtest14.prod_name = "Product " + %string(i)
		strtest14.reckey.prod_id = 1000 + i
		strtest14.reckey.company_code = 3
		strtest14.loc_grp.whrs = 5
		strtest14.loc_grp.ilegrp.row = 10 + i
		strtest14.loc_grp.ilegrp.shelf = 50 + i
.ifdef DBLNET
		aStr1 = strtest14
		arylst.add(aStr1)
.else
		abox = (@a)strtest14
		arylst.add(abox)
.endc
		writes(chan, strtest14)
	end
	a_al = arylst
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; --------------------------------------------------------------------------

{xfMethod(interface="IF913",name="DTArrayGroupStrs",elb="TEST:if913",id="DTArrayGroupStrs")}
subroutine DTArrayGroupStrs
	{xfParameter(name="STRTEST12",structure="Strtest12",collectionType=xfCollectType.structure,dataTable=true)}
	req out     a_al   ,@System.Collections.ArrayList ;;
	endparams
;.subroutine DTArrayGroupStrs
;       Arguments
;        required a_al         ,@System.Collections.ArrayList


	record strtest12                                            
		STR12_AL10         ,A10   ; (1,10) Alpha of 10                                
		group STR12_STRARY ,[3]A  ; (11,49)                                           
			STR12_GP1DE5     ,D5    ;   (1,5)                                           
			STR12_GP1AL8     ,A8    ;   (6,13)                                          
		endgroup                  ; end group STR12_STRARY                            
		STR12_DE7          ,D7    ; (50,56)                                           
	
.align
	record
		chan    ,i4
		i	,i4
		abox	,@a
		aStr1	,strtest12

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	arylst = new System.Collections.ArrayList()

	for i from 1 thru 3 by 1
	begin
		clear strtest12
		str12_al10 = "name" + %string(i)
		str12_de7 = i + 1
		case i of
		begincase
		1 : begin
			str12_strary[1].str12_gp1de5 = 12343
			str12_strary[1].str12_gp1al8 = "rupert12"
			str12_strary[2].str12_gp1de5 = 78922
			str12_strary[2].str12_gp1al8 = "rupert22"
			str12_strary[3].str12_gp1de5 = 17854
			str12_strary[3].str12_gp1al8 = "rupert32"
		end
		2 : begin
			str12_strary[1].str12_gp1de5 = 98547
			str12_strary[1].str12_gp1al8 = "rupert72"
			str12_strary[2].str12_gp1de5 = 87546
			str12_strary[2].str12_gp1al8 = "rupert82"
			str12_strary[3].str12_gp1de5 = 28541
			str12_strary[3].str12_gp1al8 = "rupert92"
		end
		3 : begin
			str12_strary[1].str12_gp1de5 = 32145
			str12_strary[1].str12_gp1al8 = "rupert41"
			str12_strary[2].str12_gp1de5 = 35895
			str12_strary[2].str12_gp1al8 = "rupert51"
			str12_strary[3].str12_gp1de5 = 36985
			str12_strary[3].str12_gp1al8 = "rupert61"
		end
		endcase
.ifdef DBLNET
		aStr1 = strtest12
		arylst.add(aStr1)
.else
		abox = (@a)strtest12
		arylst.add(abox)
.endc
		writes(chan, strtest12)
	end
	a_al = arylst
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; ------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="NullableDTStr",elb="TEST:if913",id="NullAbleDTStr")}
subroutine NullableDTStr
	{xfParameter(name="NULLDTSTR",structure="strNulldtstr")}
	req inout   a_date   ,strNulldtstr              ;;
	endparams
;.subroutine NullableDTStr
;	a_date, a

	record DateTimeStr                                          
		DTS_ALPHA ,A10  ; (1,10)                                                      
		DTS_DATE8 ,A8   ; (11,18)                                                     
		DTS_DATE6 ,D6   ; (19,24)                                                     
		DTS_TIME6 ,D6   ; (25,30)                                                     
		DTS_TIME4 ,D4   ; (31,34)                                                     
.proc
	clear DateTimeStr
	dts_alpha = "hey"
	dts_date6 = 090214
	dts_time6 = 112309
	dts_time4 = 0
	dts_date8 = 0

;	case idx of
;	begincase
;	0:	dts_date8 = "20050520"
;	1: 	dts_date8 = "00      "
;	2:      dts_date8 = "      00"
;	3: 	dts_date8 = "0 0 0 0 "
;	4: 	dts_date8 = "  000   "
;	endcase

	a_date = DateTimeStr
	xreturn
.end

; ------------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="NullableDTAry",elb="TEST:if913",id="NullableDTAry")}
subroutine NullableDTAry
	{xfParameter(name="NULLDTARY",structure="strNulldtary")}
	req inout   a_dtetmeary   ,strNulldtary              ;;
	endparams
;.subroutine NullableDTAry
;	Arguments
;	a_dtetmeary	,a	

; .include "DateTimeAry.rec"
	.include "DateTimeAry" repository, record="DateTimeAry", end
.align
	record
		ndx	,i4

.proc
	DateTimeAry =  a_dtetmeary
	clear DateTimeAry  
	adts_dt8[1] = 0
	adts_dt8[2] = 0
	adts_dt8[3] = 20090415
	adts_dt6[1] = 0
	adts_dt6[2] = 0
	adts_dt6[3] = 090415
	adts_dt7[1] = 0
	adts_dt7[2] = 0
	adts_dt7[3] = 0
	adts_dt5[1] = 0
	adts_dt5[2] = 0
	adts_dt5[3] = 0
	adts_tm6[1] = 0
	adts_tm6[2] = 0
	adts_tm6[3] = 071503
	adts_tm4[1] = 0
	adts_tm4[2] = 0
	adts_tm4[3] = 0
	a_dtetmeary = DateTimeAry
	xreturn
.end

; ---------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="NullableDTStrAL",elb="TEST:if913",id="NullableDTStrAL")}
subroutine NullableDTStrAL
	{xfParameter(name="NULLDTSTR",structure="strNulldtstr",collectionType=xfCollectType.structure)}
	req out     a_al   ,@System.Collections.ArrayList ;;
	endparams
;.subroutine NullableDTStrAL
;       Arguments
;        required a_al         ,@System.Collections.ArrayList

	record DateTimeStr                                          
		DTS_ALPHA ,A10  ; (1,10)                                                      
		DTS_DATE8 ,A8   ; (11,18)                                                     
		DTS_DATE6 ,D6   ; (19,24)                                                     
		DTS_TIME6 ,D6   ; (25,30)                                                     
		DTS_TIME4 ,D4   ; (31,34)                                                     

	record
		chan    ,i4
		i	,i4
		ast     ,a25
		str	,@System.String
		abox	,@a
		aStr1	,strNulldtstr

		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop" ; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		clear DateTimeStr
		dts_alpha = "hey"
		dts_date6 = 0
		dts_time6 = 090415
		dts_time4 = 0835
		dts_date8 = 0
.ifdef DBLNET
		aStr1 = DateTimeStr
		arylst.add(aStr1)
.else
		abox = (@a)DateTimeStr
		arylst.add(abox)
.endc
		writes(chan, DateTimeStr)
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="NullSSandAL",elb="TEST:if913",id="NullssAL")}
function NullSSandAL    ,^val
	{xfParameter(name="CustNumber")}
	req in      custNumber  ,d1                     ;;
	{xfParameter(name="aDate",cType=xfType.DateTime,format=xfFormat.yyyymmdd)}
	req in      adate       ,d8                     ;;
	{xfParameter(name="info")}
	req out     a_str        ,string               ;;
	{xfParameter(name="STRTEST1",structure="Strtest1",collectionType=xfCollectType.structure)}
	req out     a_al    ,@System.Collections.ArrayList ;;
	endparams
;.function NullSSandAL,		^val
;       Arguments
;	custNumber		,d6
;	adate			,d8
;	required a_str		,@System.String
;       required a_al           ,@System.Collections.ArrayList

	record strtest1
		STR1_DE6  ,D6    ; (1,6) str test 1 ID field
		STR1_AL10 ,A10   ; (7,16) str t test name
		STR1_ID62 ,D6.2  ; (17,22) str 1 test ImpDec 6.2
		STR1_IN4  ,I4    ; (23,26) str test 1 interger 4
		STR1_AL20 ,A20   ; (27,46) Str test 1 Alpha 20


	
.align
	record
		chan    ,i4
		i	,i4
		rtn	,i4
		ast     ,a25
		str	,@System.String
		abox	,@a
		aStr1	,strtest1
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	str = "Bunny hop"  ; new System.String("Bunny hop")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 5
	begin
		clear strtest1
		strtest1.STR1_AL10 = "Sam One"
		strtest1.STR1_DE6 = 3200 + I
		strtest1.STR1_ID62 = 1000.23 + i
		strtest1.STR1_IN4 = 7820 + i
		strtest1.STR1_AL20 = "Some data"
.ifdef DBLNET
		aStr1 = strtest1
		arylst.add(aStr1)
.else
		abox = (@a)strtest1
		arylst.add(abox)
.endc
		writes(chan, strtest1)
	end
	a_al = arylst
	;	a_str = " "
	writes(chan, "    ")
	close (chan)
	rtn = 5
	freturn(rtn) 
.end

; ----------------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofStruct1out",elb="TEST:if913",id="ALofStruct1out")}
subroutine ALofStruct1out
	{xfParameter(name="Strtest1",structure="strtest1",collectionType=xfCollectType.structure)}
	req out     a_al ,@System.Collections.ArrayList ;;Str arylist of out
	endparams

	record aStrTst
		STR1_DE6  ,D6    ; (1,6) str test 1 ID field
		STR1_AL10 ,A10   ; (7,16) str t test name
		STR1_ID62 ,D6.2  ; (17,22) str 1 test ImpDec 6.2
		STR1_IN4  ,I4    ; (23,26) str test 1 interger 4
		STR1_AL20 ,A20   ; (27,46) Str test 1 Alpha 20

	
.align
	record
		chan    ,i4
		i	,i4
		abox	,@a
		aSt1	,Strtest1
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 3
	begin
		clear aStrtst
		aStrTst.STR1_DE6 = 2345
		aStrTst.STR1_AL10 = "Sam One"
		aStrTst.STR1_AL20 = "Sam  Onehundred"
		aStrTst.STR1_IN4 = 40 + I
		aStrTst.STR1_ID62 = 1000.23 + i
.ifdef DBLNET
		aSt1 = aStrTst
		arylst.add(aSt1)
.else
		abox = (@a)aStrTst
		arylst.add(abox)
.endc
		writes(chan, aStrTst)
	end
	a_al = arylst

	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="ALofStruct1",elb="TEST:if913",id="ALofStruct1")}
subroutine ALofStruct1
	{xfParameter(name="strtest1",structure="strtest1",collectionType=xfCollectType.structure)}
	req in      a_al ,@System.Collections.ArrayList 
	endparams

	record aStrTst
		STR1_DE6  ,D6    ; (1,6) str test 1 ID field
		STR1_AL10 ,A10   ; (7,16) str t test name
		STR1_ID62 ,D6.2  ; (17,22) str 1 test ImpDec 6.2
		STR1_IN4  ,I4    ; (23,26) str test 1 interger 4
		STR1_AL20 ,A20   ; (27,46) Str test 1 Alpha 20

	
.align
	record
		chan    ,i4
		i	,i4
		astr	,a25
		abox	,@a
		aSt1	,strtest1
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	arylst = a_al
	for i from 0 thru 2
	begin
		aSt1 = (strtest1)arylst[i]
		aStrTst = aSt1
		writes(chan, aStrTst)
		writes(chan, aStrTst.STR1_AL10)
		writes(chan, %string(aStrTst.STR1_DE6))
		writes(chan, %string(aStrTst.STR1_IN4))
	end

	writes(chan, "    ")
	close (chan)
	xreturn 
.end
; -------------------------------------------------------------------

{xfMethod(interface="IF913",name="TrueBool",elb="TEST:if913",id="TrueBool")}
function TrueBool        ,boolean
	{xfParameter(name="BoolParm")}
	req inout   a_i   ,boolean
	endparams

.align
	record
		chan    ,i4
		ndx     ,i4
		b1      ,boolean
		b2		,boolean
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	b1 = true
	b2 = a_i
	if (b2) then
		a_i = false
	else
		a_i = true;
	a_i = b2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, " IntBool")
;;      writes(chan, i1)
;;      writes(chan, i2)
;;      writes(chan, "IntBool")
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (b1)
.end

; -------------------------------------------------------------------

{xfMethod(interface="IF913",name="BoolToBool",elb="TEST:if913",id="BoolToBool")}
function BoolToBool        ,i4
	{xfParameter(name="Favorite")}
	inout   required    a_favorite             ,i4         
	endparams

.align
	record
		chan    ,i4
		b1      ,i4
		b2	,i4
.proc
	chan = 211
;;      open(chan, a, "TESTif913.log")
	b1 = true
	b2 = true
	a_favorite = b2
;;      writes(chan, "    ")
;;      writes(chan, " ********************************")
;;      writes(chan, b1)
;;      writes(chan, b2)
;;      writes(chan, " ********************************")
;;      writes(chan, "    ")
;;      close (chan)
	freturn (b1)
.end
; ---------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="BoolStruct1",elb="TEST:if913",id="BoolStruct1")}
subroutine BoolStruct1
	{xfParameter(structure="strBooleanstr")}
	req inout   a_str1    ,strBooleanstr               
	endparams
	
.align
	record
		chan	,i4
		ndx		,i4
		msg		,a30
		bstr1	,strBooleanstr
		
.proc
	chan = 211
	bstr1 =  a_str1	
	bstr1.al10 = "Hi there"
	bstr1.typebool1 = true
	bstr1.int1ctbool = true
	bstr1.int2ctbool = true
	bstr1.int4ctbool = true
	bstr1.int8ctbool = true
	bstr1.dec3ctbool = true
	bstr1.dec6ctbool = true
	bstr1.dec9ctbool = true
	bstr1.dec13ctbool = true
	bstr1.dec17ctbool = true
	a_str1 = bstr1
	xreturn
.end

; ----------------------------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="BoolStruct3AlOut",elb="TEST:if913",id="BoolStruct3AlOut")}
subroutine BoolStruct3AlOut
	{xfParameter(name="BALout",structure="strBooleanstr",collectionType=xfCollectType.structure)}
	req out     a_al ,@System.Collections.ArrayList ;;Str arylist of out
	endparams

	record aboolStr                                              
		tAL10        ,A10      ; (1,10)                                                
		tTYPEBOOL1   ,Boolean  ; (11,14)                                               
		tINT1CTBOOL  ,I1       ; (15,15)                                               
		tINT2CTBOOL  ,I2       ; (16,17)                                               
		tINT4CTBOOL  ,I4       ; (18,21)                                               
		tINT8CTBOOL  ,I8       ; (22,29)                                               
		tDEC3CTBOOL  ,D3       ; (30,32)                                               
		tDEC6CTBOOL  ,D6       ; (33,38)                                               
		tDEC9CTBOOL  ,D9       ; (39,47)                                               
		tDEC13CTBOOL ,D13      ; (48,60)                                               
		tDEC17CTBOOL ,D17      ; (61,77)         		
		
.align
	record
		chan    ,i4
		i	,i4
		abox	,@a
		bstr1	,strBooleanstr
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	arylst = new System.Collections.ArrayList()
	for i from 1 thru 3
	begin
		aboolStr.tal10 = "Hi there " + ^a(i)
		aboolStr.ttypebool1 = true
		aboolStr.tint1ctbool = true
		aboolStr.tint2ctbool = true
		aboolStr.tint4ctbool = true
		aboolStr.tint8ctbool = true
		aboolStr.tdec3ctbool = true
		aboolStr.tdec6ctbool = true
		aboolStr.tdec9ctbool = true
		aboolStr.tdec13ctbool = true
		aboolStr.tdec17ctbool = true
.ifdef DBLNET
		bstr1 = aboolStr
		arylst.add(bstr1)
.else
		abox = (@a)aboolStr
		arylst.add(abox)
.endc
		writes(chan, aboolStr)
	end
	a_al = arylst
	
	writes(chan, "    ")
	close (chan)
	xreturn 
.end

; -------------------------------------------------------------------------------

{xfMethod(interface="IF913",name="BoolStruct2Al",elb="TEST:if913",id="BoolStruct2Al")}
subroutine BoolStruct2Al
	{xfParameter(name="BALin",structure="strBooleanstr",collectionType=xfCollectType.structure)}
	req in      a_al ,@System.Collections.ArrayList 
	endparams
	
	record aboolStr                                              
		tAL10        ,A10      ; (1,10)                                                
		tTYPEBOOL1   ,Boolean  ; (11,14)                                               
		tINT1CTBOOL  ,I1       ; (15,15)                                               
		tINT2CTBOOL  ,I2       ; (16,17)                                               
		tINT4CTBOOL  ,I4       ; (18,21)                                               
		tINT8CTBOOL  ,I8       ; (22,29)                                               
		tDEC3CTBOOL  ,D3       ; (30,32)                                               
		tDEC6CTBOOL  ,D6       ; (33,38)                                               
		tDEC9CTBOOL  ,D9       ; (39,47)                                               
		tDEC13CTBOOL ,D13      ; (48,60)                                               
		tDEC17CTBOOL ,D17      ; (61,77)   
		
.align
	record
		chan    ,i4
		i		,i4
		abox	,@a
		bstr1	,strBooleanstr
		arylst	,@System.Collections.ArrayList
.proc
	chan = 211
	open(chan, a, "TEST:if913.log")
	
	arylst = a_al
	for i from 0 thru 2
	begin
		bstr1 = (strBooleanstr)arylst[i]
		aboolStr = bstr1
		writes(chan, aboolStr)
		writes(chan, aboolStr.tAL10)
		writes(chan, %string(aboolStr.tINT4CTBOOL))
		writes(chan, %string(aboolStr.tDEC9CTBOOL))
	end
	
	writes(chan, "    ")
	close (chan)
	xreturn 
.end
; -------------------------------------------------------------------
