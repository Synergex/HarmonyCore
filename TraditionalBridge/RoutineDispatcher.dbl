import System.Collections
import TraditionalBridge
import Json

.ifdef DBLV11
import System.Text.Json
.define JSON_ELEMENT @JsonElement
.define IS_OBJ(element) ((element).ValueKind == JsonValueKind.Object)
.define IS_NUMBER(element) ((element).ValueKind == JsonValueKind.Number)
.define IS_TEXT(element) ((element).ValueKind == JsonValueKind.String)
.define IS_ARRAY(element) ((element).ValueKind == JsonValueKind.Array)
.define IS_BOOLEAN(element) ((element).ValueKind == JsonValueKind.True || (element).ValueKind == JsonValueKind.False)
.define GET_ELEMENT_TYPENAME(element) %string(element.ValueKind)
.else
.define JSON_ELEMENT @JsonValue
.define IS_OBJ(element) ((element).JsonType == JSON_TYPE.OBJ)
.define IS_NUMBER(element) ((element).JsonType == JSON_TYPE.NUMBER || (element).JsonType == JSON_TYPE.INT_VAL)
.define IS_TEXT(element) ((element).JsonType == JSON_TYPE.TEXT)
.define IS_ARRAY(element) ((element).JsonType == JSON_TYPE.ARRAY_VAL)
.define IS_BOOLEAN(element) ((element).JsonType == JSON_TYPE.BOOL)
.define GET_ELEMENT_TYPENAME(element) %string(element.JsonType)
.endc

.define TEMP_AD_TYPE a28
.define MaybeLog(priority, msg) if((priority) <= Logger.LogLevel) Logger.Instance.Log(msg)
;.define MaybeLog(priority, msg) Logger.Instance.Log(msg)

namespace Harmony.TraditionalBridge

    ;;; <summary>
    ;;; 
    ;;; </summary>
    public abstract class RoutineDispatcher

        public MaxRequestId, int
        ;;dummy structure for ^m operations on the mReadBuffer
        private structure MemStruct
            fld, a1
        endstructure

        protected mReadBuffer, D_HANDLE
        protected mReadBufferSize, int
        protected mDispatchStubs, @StringDictionary
        protected mActivationMask, [32]i1
.define GetBuffer ^m(MemStruct(1:mReadBufferSize), mReadBuffer)

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        public method RoutineDispatcher
        proc
            MaxRequestId = 0
            ;;setchars(mActivationMask, 3, 4, 25, 26)
            mDispatchStubs = new StringDictionary()
            mReadBufferSize = 0
            mReadBuffer = 0
            MaybeLog(5, "Creating RoutineDispatcher")
        endmethod

        method ~RoutineDispatcher
        proc
            if(mReadBuffer != 0)
                mReadBuffer = %mem_proc(DM_FREE, mReadBuffer)

            mReadBufferSize = 0
            MaybeLog(5, "Destroying RoutineDispatcher")
        endmethod

        public virtual method BeforeDispatch, void
            name, @string
            callFrame, JSON_ELEMENT
            serializer, @DispatchSerializer
        proc

        endmethod

        public virtual method AfterDispatch, void
            name, @string
            callFrame, JSON_ELEMENT
            serializer, @DispatchSerializer
        proc

        endmethod

        ;;; <summary>
        ;;; Deserialize a JSON object to a data object
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <param name="targetType">Instance of a data object metadata class indicating the type to deserialize to</param>
        ;;; <returns>A data object of the appropriate type</returns>
        public virtual method DeserializeObject, @DataObjectBase
            obj, JSON_ELEMENT
            targetType, @DataObjectMetadataBase
            record
                passedValue, JSON_ELEMENT
                objectMetadata, @DataObjectMetadataBase
                objectType, @string
            endrecord
        proc
            passedValue = obj.GetProperty("PassedValue")
            objectMetadata = targetType
            if(objectMetadata == ^null)
            begin
                objectType = passedValue.GetProperty("Type").GetString()
                objectMetadata = DataObjectMetadataBase.LookupType(objectType)
            end
            mreturn objectMetadata.Deserialize(passedValue)
        endmethod

        ;;Protocol note: this is another place where we need to decide how much we can ommit from the contents of collections
        ;;this is currently assuming we are only working with DataObjectBase

        ;;; <summary>
        ;;; Deserializes a JSON object containing a collection of serialized data objects into an ArrayList of data objects.
        ;;; Each of the data objects in the collection could be of a different type.
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <returns>ArrayList containing data objects.</returns>
        public virtual method DeserializeObjectCollection, @ArrayList
            obj, JSON_ELEMENT
            record
                passedValue, JSON_ELEMENT
                elementValue, JSON_ELEMENT
                elementObject, JSON_ELEMENT
                objectMetadata, @DataObjectMetadataBase
                objectType, @string
                result, @ArrayList
                elementIsEncodedProp, JSON_ELEMENT
                elementIsEncoded, boolean
                elementTypeValue, JSON_ELEMENT
                isBriefEncoding, boolean
                i, int
                collectionSize, int
            endrecord
        proc
            isBriefEncoding = false
            elementIsEncoded = false
            result = new ArrayList()
            passedValue = obj.GetProperty("PassedValue")

            if(obj.TryGetProperty("ElementIsEncoded", elementIsEncodedProp))
                elementIsEncoded = elementIsEncodedProp.GetBoolean()

            if(obj.TryGetProperty("ElementType", elementTypeValue))
            begin
                isBriefEncoding = true
                objectMetadata = DataObjectMetadataBase.LookupType(elementTypeValue.GetString())
            end
            collectionSize = passedValue.GetArrayLength()
            for i from 0 thru collectionSize - 1 by 1
            begin
                elementValue = passedValue[i]

                ;;TODO might be able to skip the lookup if the typename hasnt changed
                if(!isBriefEncoding) then
                begin
                    if(IS_OBJ(elementValue)) then 
                    begin
                        elementObject = elementValue
                        objectType = elementObject.GetProperty("Type").GetString()
                        objectMetadata = DataObjectMetadataBase.LookupType(objectType)
                        result.Add(objectMetadata.Deserialize(elementObject))
                    end
                    else if(IS_TEXT(elementValue)) then
                    begin
                        result.Add(elementValue.GetString())
                    end
                    else if(IS_NUMBER(elementValue)) then
                    begin
                        result.Add((@*)elementValue.GetDecimal())
                    end
                    ;else if(elementValue .is. @JsonBoolean) then
                    ;  begin
                    ;	result.Add(((@JsonBoolean)elementValue).Value)
                    ;  end
                    else
                        throw new Exception("unknown collection encoding")
                end
                else if(elementIsEncoded) then
                begin
                    result.Add(objectMetadata.MakeNew(elementValue.GetStringFromBase64(), ""))
                end
                else
                begin
                    result.Add(objectMetadata.MakeNew(elementValue.GetString(), ""))
                end
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="memoryHandle"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            memoryHandle, i4
            collection, @ArrayList
        proc
                        
        endmethod

        public method UnwrapObjectCollection, void
            dataDef, @ArgumentDataDefinition
            jsonArray, JSON_ELEMENT
            arrayList, @ArrayList
            optional desiredType, FieldDataType
            record
                result, @ArrayList
                buffer, a65535
                typeTemp, FieldDataType
            endrecord
        proc
            if(^passed(desiredType)) then
                typeTemp = desiredType
            else
                typeTemp = FieldDataType.AlphaField

            UnwrapObjectCollection(jsonArray, arrayList, dataDef.ElementIsEncoded, ^null, buffer, typeTemp, dataDef.ElementSize, dataDef.DecimalPrecision)
        endmethod

        ;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="buffer"></param>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="bufferPosition"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            inout buffer, a
            elementInfo, @ArgumentDataDefinition
            inout bufferPosition, i
            collection, JSON_ELEMENT
            record
                element, JSON_ELEMENT
                itr, int
                collectionSize, int
            endrecord
        proc
            collectionSize = collection.GetArrayLength()
            for itr from 0 thru collectionSize - 1 by 1
            begin
                element = collection[itr]
                if(IS_OBJ(element)) then
                begin
                    data valueToken, JSON_ELEMENT
                    data stringValue, @string
                    if(element.TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = valueToken.GetString()
                    end
                    else
                    begin
                        stringValue = element.GetProperty("Base64Value").GetStringFromBase64()
                    end
                    buffer(bufferPosition:elementInfo.ElementSize) = stringValue
                end
                else if(IS_TEXT(element)) then
                begin
                    buffer(bufferPosition:elementInfo.ElementSize) = element.GetString()
                end
                else if(IS_NUMBER(element)) then
                begin
                    if(elementInfo.DataType == FieldDataType.IntegerField) then
                        ^i(buffer(bufferPosition:elementInfo.ElementSize)) = element.GetDecimal()
                    else
                        ^d(buffer(bufferPosition:elementInfo.ElementSize), elementInfo.DecimalPrecision) = element.GetDecimal()
                end
                else if(IS_BOOLEAN(element)) then
                begin
                                        
                end
                else if(IS_ARRAY(element))
                begin

                end
                bufferPosition += elementInfo.ElementSize
            end

        endmethod

        public method UnwrapObjectCollection, void
            handle, D_HANDLE
            elementInfo, @ArgumentDataDefinition
            inout bufferPosition, i
            collection, JSON_ELEMENT
            structure localStr
                fld, a1
            endstructure
            record
                element, JSON_ELEMENT
                itr, int
                collectionSize, int
            endrecord
        proc
            collectionSize = collection.GetArrayLength()
            MaybeLog(6, "UnwrapObjectCollection handle collectionSize: " + %string(collectionSize))
            for itr from 0 thru collectionSize - 1 by 1
            begin
                MaybeLog(6, "UnwrapObjectCollection handle element: " + %string(itr))
                element = collection[itr]
                if(IS_OBJ(element)) then
                begin
                    data valueToken, JSON_ELEMENT
                    data stringValue, @string
                    if(element.TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = valueToken.GetString()
                    end
                    else
                    begin
                        stringValue = element.GetProperty("Base64Value").GetStringFromBase64()
                    end
                    MaybeLog(6, "filling handle bufferPosition: " + %string(bufferPosition) + " elementSize: " + %string(elementInfo.ElementSize) + " value:" + stringValue)
                    ^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle) = stringValue
                end
                else if(IS_TEXT(element)) then
                begin
                    MaybeLog(6, "filling handle bufferPosition: " + %string(bufferPosition) + " elementSize: " + %string(elementInfo.ElementSize) + " value:" + element.GetString())
                    ^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle) = element.GetString()
                end
                else if(IS_NUMBER(element)) then
                begin
                    if(elementInfo.DataType == FieldDataType.IntegerField) then
                        ^i(^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle)) = element.GetDecimal()
                    else
                        ^d(^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle), elementInfo.DecimalPrecision) = element.GetDecimal()
                end
                else if(IS_BOOLEAN(element)) then
                begin
                                        
                end
                else if(IS_ARRAY(element))
                begin

                end
                bufferPosition += elementInfo.ElementSize
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="argument"></param>
        ;;; <returns></returns>
        public method GetArgumentDataDefForCollection, @ArgumentDataDefinition
            argument, JSON_ELEMENT
            in optional elementSize, int
            in optional decimalPrecision, int
            record
                result, @ArgumentDataDefinition
                dataType, i4
                temp, JSON_ELEMENT
            endrecord
        proc
            result = new ArgumentDataDefinition()
            result.ElementSize = ^passed(elementSize) ? elementSize : 0
            result.DecimalPrecision = ^passed(decimalPrecision) ? decimalPrecision : 0

            if(argument.TryGetProperty("DecimalPrecision", temp))
                result.DecimalPrecision = temp.GetInt32()

            if(argument.TryGetProperty("ElementSize", temp))
                result.ElementSize = temp.GetInt32()

            if(argument.TryGetProperty("DataType", temp))
                result.DataType = (FieldDataType)temp.GetInt32()

            if(argument.TryGetProperty("ReturnedValue", temp))
                result.ReturnedValue = temp.GetBoolean()

            mreturn result

        endmethod

        ;;TODO: This needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        public method UnwrapObjectCollection, @ArrayList
            collection, JSON_ELEMENT
            record
                result, @ArrayList
                buffer, a65535
        proc
            result = new ArrayList()
            UnwrapObjectCollection(collection, result, false, ^null, buffer)
            mreturn result
        endmethod

        private method UnwrapJsonValue, @object
            element, JSON_ELEMENT
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            optional grfa, a
        proc
            if(IS_TEXT(element)) then
            begin
                if(^passed(desiredSize)) then
                begin
                    if(!^passed(desiredType)) then
                    begin
                        elementBuffer(1: desiredSize) = element.GetString()
                        MaybeLog(6, "unwrapjsonvalue Alpha: " + elementBuffer(1: desiredSize))
                        mreturn (@*)elementBuffer(1: desiredSize)
                    end
                    else if(desiredType == FieldDataType.DataObjectField) then
                    begin
                        elementBuffer(1: desiredSize) = element.GetString()

                        MaybeLog(6, "unwrapjsonvalue Object: " + elementBuffer(1: desiredSize))
                        if(^passed(grfa)) then
                            mreturn elementType.MakeNew(elementBuffer(1: desiredSize), grfa)
                        else
                            mreturn elementType.MakeNew(elementBuffer(1: desiredSize), "")
                    end
                    else if(desiredType == FieldDataType.StringField) then
                    begin
                        MaybeLog(6, "unwrapjsonvalue String: " + element.GetString())
                        mreturn element.GetString()
                    end
                    else if(desiredType == FieldDataType.AlphaField)
                    begin
                        elementBuffer(1: desiredSize) = element.GetString()
                        MaybeLog(6, "unwrapjsonvalue Alpha explicit: " + elementBuffer(1: desiredSize))
                        mreturn (@*)elementBuffer(1: desiredSize)
                    end
                end
                else
                begin
                    MaybeLog(6, "unwrapjsonvalue unsized Alpha: " + (a)element.GetString())
                    mreturn (@a)(a)element.GetString()
                end
            end
            else if(IS_NUMBER(element)) then
            begin
                if(!^passed(desiredType)) then
                begin
                    ^d(elementBuffer(1: 28), 10) = element.GetDecimal()
                    mreturn (@*)^d(elementBuffer(1: 28), 10)
                end
                else if(desiredType == FieldDataType.IntegerField) then
                begin
                    ^i(elementBuffer(1: desiredSize)) = element.GetInt64()
                    mreturn (@*)^i(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.DecimalField) then
                begin
                    ^d(elementBuffer(1: desiredSize)) = element.GetDecimal()
                    mreturn (@*)^d(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.ImpliedDecimal) then
                begin
                    ^d(elementBuffer(1: desiredSize), desiredPrecision) = element.GetDecimal()
                    mreturn (@*)%implied(^d(elementBuffer(1: desiredSize), desiredPrecision))
                end
                else
                    throw new Exception("invalid desired type " + %string(desiredType))
            end
            else if(IS_BOOLEAN(element)) then
            begin
                mreturn (@boolean)element.GetBoolean()
            end
            else if(IS_ARRAY(element)) then
            begin
                throw new Exception("invalid element type was: ARRAY")
            end
            else if(IS_OBJ(element)) then
            begin
                throw new Exception("invalid element type was: OBJECT")
            end
            else
            begin
                throw new Exception("invalid element type was: " + GET_ELEMENT_TYPENAME(element))
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="collection"></param>
        ;;; <param name="targetArrayList"></param>
        public method UnwrapObjectCollection, void
            collection, JSON_ELEMENT
            ;;must be an arraylist or a typed dynamic array
            targetCollection, @Array
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            record
                element, JSON_ELEMENT
                index, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            if(targetCollection.Length != collectionLength)
                throw new Exception("Dynamic array must be correctly sized before unwrapping object collection into it")
            
            MaybeLog(6, "UnwrapObjectCollection array collectionSize: " + %string(collectionLength))

            for index from 1 thru collectionLength by 1
            begin
                MaybeLog(6, "UnwrapObjectCollection array element: " + %string(index - 1))

                element = collection[index - 1]
                if(IS_OBJ(element)) then
                begin
                    data valueToken, JSON_ELEMENT
                    if(element.TryGetProperty("Value", valueToken)) then
                    begin
                        if(elementType != ^null && ^passed(desiredType) && desiredType == FieldDataType.AlphaField) then
                            elementType.SetIntoArray((@a)UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), targetCollection, index)
                        else
                            targetCollection.SetValue(UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                    end
                    else
                    begin
                        targetCollection.SetValue(UnwrapJsonValue(element.GetProperty("Base64Value"), true, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                    end
                end
                else
                begin
                    if(elementType != ^null && ^passed(desiredType) && desiredType == FieldDataType.AlphaField) then
                        elementType.SetIntoArray((@a)UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), targetCollection, index)
                    else
                        targetCollection.SetValue(UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                end
            end
        endmethod

        public method UnwrapObjectCollection, void
            collection, JSON_ELEMENT
            ;;must be an arraylist or a typed dynamic array
            targetCollection, @ArrayList
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            record
                element, JSON_ELEMENT
                i, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            MaybeLog(6, "collection array length:" + %string(collectionLength))
            for i from 0 thru collectionLength - 1 by 1
            begin
                MaybeLog(6, "indexing array:" + %string(i) + " for array of length:" + %string(collectionLength))
                element = collection[i]
                if(IS_OBJ(element)) then
                begin
                    data valueToken, JSON_ELEMENT
                    if(element.TryGetProperty("Value", valueToken)) then
                    begin
                        targetCollection.Add(UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                    end
                    else
                    begin
                        targetCollection.Add(UnwrapJsonValue(element.GetProperty("Base64Value"), true, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                    end
                end
                else
                begin
                    targetCollection.Add(UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                end
            end
        endmethod

        public method UnwrapStringArray, [#]@string
            collection, JSON_ELEMENT
            record
                result, [#]@string
                element, JSON_ELEMENT
                i, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            result = new string[collectionLength]
            for i from 0 thru collectionLength - 1 by 1
            begin
                element = collection[i]
                if(IS_TEXT(element)) then
                begin
                    result[i + 1] = element.GetString()
                end
                else
                    throw new InvalidCastException()
            end
            mreturn result
        endmethod

        public method UnwrapIntArray, [#]int
            collection, JSON_ELEMENT
            record
                result, [#]int
                element, JSON_ELEMENT
                i, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            result = new int[collectionLength]
            for i from 0 thru collectionLength - 1 by 1
            begin
                element = collection[i]
                if(IS_NUMBER(element)) then
                begin
                    result[i + 1] = element.GetInt32()
                end
                else
                    throw new InvalidCastException()
            end
            mreturn result
        endmethod

        public method UnwrapBoolArray, [#]boolean
            collection, JSON_ELEMENT
            record
                result, [#]boolean
                element, JSON_ELEMENT
                i, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            result = new boolean[collectionLength]
            for i from 0 thru collectionLength - 1 by 1
            begin
                element = collection[i]
                if(IS_BOOLEAN(element)) then
                begin
                    result[i + 1] = element.GetBoolean()
                end
                else
                    throw new InvalidCastException()
            end
            mreturn result
        endmethod

        public method UnwrapImpliedDecimalArray, [#]@id
            collection, JSON_ELEMENT
            record
                result, [#]@id
                element, JSON_ELEMENT
                i, int
                collectionLength, int
            endrecord
        proc
            collectionLength = collection.GetArrayLength()
            result = new @id[collectionLength]
            for i from 0 thru collectionLength - 1 by 1
            begin
                element = collection[i]
                if(IS_NUMBER(element)) then
                begin
                    result[i + 1] = (@id)element.GetDecimal()
                end
                else
                    throw new InvalidCastException()
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetText, @string
            value, JSON_ELEMENT
        proc
            mreturn value.GetProperty("PassedValue").GetString()
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetInt, i
            value, JSON_ELEMENT
        proc
            mreturn value.GetProperty("PassedValue").GetInt64()
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetBoolean, boolean
            value, JSON_ELEMENT
        proc
            mreturn value.GetProperty("PassedValue").GetBoolean()
        endmethod

        public method GetArray, JSON_ELEMENT
            value, JSON_ELEMENT
        proc
            mreturn value.GetProperty("PassedValue")
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetDecimal, d
            value, JSON_ELEMENT
            record
                passedValue, JSON_ELEMENT
            endrecord
        proc

            passedValue = value.GetProperty("PassedValue")
            if(IS_TEXT(passedValue)) then
                mreturn ^d((a)passedValue.GetString())
            else
                mreturn passedValue.GetDecimal()
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetImplied, d.
            value, JSON_ELEMENT
            record
                precisionValue, d18
                aVal, TEMP_AD_TYPE
                passedValue, JSON_ELEMENT
                precisionElement, JSON_ELEMENT
            endrecord
        proc
            passedValue = value.GetProperty("PassedValue")

            if(IS_TEXT(passedValue)) then
            begin
                mreturn %implied(passedValue.GetString())
            end
            else
            begin
                if(value.TryGetProperty("DecimalPrecision", precisionElement)) then
                begin
                    aVal = ^a(passedValue.GetDecimal())
                    mreturn ^d(aVal,precisionElement.GetDecimal())
                end
                else
                    mreturn passedValue.GetDecimal()
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="dataType"></param>
        ;;; <returns></returns>
        public method DeserializeObject, @object
            obj, JSON_ELEMENT
            out dataType, FieldDataType
            record
                propValue, JSON_ELEMENT
            endrecord
        proc
            dataType = (FieldDataType)obj.GetProperty("DataType").GetInt32()
            if(dataType == FieldDataType.DataObjectField) then
            begin
                mreturn DeserializeObject(obj, ^null)
            end
            else if(dataType == FieldDataType.DataObjectCollectionField) then
            begin
                mreturn DeserializeObjectCollection(obj)
            end
            else
            begin
                obj.TryGetProperty("PassedValue", propValue)
                if(dataType == FieldDataType.AlphaField) then
                begin
                    if(propValue == ^null) then
                        mreturn (@object)""
                    else
                    begin
                        mreturn propValue.GetString()
                    end
                end
                else if(dataType == FieldDataType.DecimalField) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn propValue.GetString()
                    end
                end
                else if(dataType == FieldDataType.ImpliedDecimal) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn propValue.GetString()
                    end
                end
                else if(dataType == FieldDataType.IntegerField)
                begin
                    data intValue, i4, 0
                    if(propValue != ^null)
                        intValue = propValue.GetInt32()
                                
                    mreturn (@object)intValue
                end
            end

        endmethod

        private method ReadContent, void
            header, ContentHeader
            messageReader, @HeaderDelimitedMessageReader
            out jsonDoc, @object
            out parsedJson, JSON_ELEMENT
        proc
            ;;reuse the same buffer if possible
            if(mReadBufferSize < header.length)
            begin
                if(mReadBuffer != 0) then
                begin
                    MaybeLog(6, "Dispatcher: reallocating buffer was " + %string(mReadBufferSize) + " -> " + %string(header.length) )
                    mReadBuffer = %mem_proc(DM_RESIZ, header.length, mReadBuffer)
                    mReadBufferSize = header.length
                end
                else
                begin
                    MaybeLog(6, "Dispatcher: allocating buffer with length" + %string(header.length))
                    mReadBuffer = %mem_proc(DM_ALLOC | DM_STATIC, header.length)
                    mReadBufferSize = header.length
                end
            end

            messageReader.ReadContent(header, mReadBuffer, mReadBufferSize, jsonDoc, parsedJson) 
        endmethod
        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        ;;; <param name="frameHeader"></param>
        ;;; <returns></returns>
        private method ReadCallBlock, boolean
            messageReader, @HeaderDelimitedMessageReader
            serializer, @DispatchSerializer
            header, ContentHeader
            record
                jsonDoc, @object
                parsedJson, JSON_ELEMENT
                result, boolean
            endrecord
        proc
            ReadContent(header, messageReader, jsonDoc, parsedJson)
            
            if (!(IS_OBJ(parsedJson)) && !(IS_ARRAY(parsedJson)))
            begin
                serializer.ReportError("failed to parse json request", (int)-32700, (int)-1)
                mreturn true
            end

            MaybeLog(5, "Dispatcher: Finished Json Parsing")

            result = true
            if(IS_OBJ(parsedJson)) then
            begin
                MaybeLog(5, "Dispatcher: Single Call")
                result = ProcessCallBlock(parsedJson, serializer)
            end
            else if(IS_ARRAY(parsedJson))
            begin
                data jsonVal, JSON_ELEMENT
                data i, int
                data collectionSize, int
                MaybeLog(5, "Dispatcher: Batch Call")

                collectionSize = parsedJson.GetArrayLength()

                serializer.ArrayOpen()
                for i from 1 thru collectionSize - 1 by 1
                begin
                    jsonVal = parsedJson[i]
                    if(IS_OBJ(jsonVal)) then
                    begin
                        result = ProcessCallBlock(parsedJson, serializer)
                        if(!result)
                            exitloop
                    end
                    else
                    begin
                        serializer.ReportError("failed to parse json request", (int)-32700, (int)-1)
                    end
                end
                serializer.ArrayClose()
            end
            serializer.Flush()
            mreturn result

        endmethod

        public method Dispatch, void
            messageReader, @HeaderDelimitedMessageReader
            serializer, @DispatchSerializer
            record
                running, boolean
                header, ContentHeader
        proc
            try
            begin
                running = true
                while(running)
                begin
                    messageReader.ReadHeader(header)
                    if(header.endOfConnection) then
                        running = false
                    else
                    begin
                        MaybeLog(5, "Dispatcher: starting callblock processing with ContentLength " + %string(header.length) + " ContentType " + %atrim(header.contentTypeBuffer))

                        running = ReadCallBlock(messageReader, serializer, header)
                        Logger.Instance.FinishMemoryLog()
                    end

                end
                MaybeLog(1, "Shutting down due to running == false")
            end
            catch(ex, @Exception)
            begin
                try
                begin
                    serializer.ReportError(ex.ToString(), (int)-32603, (int)-1)
                end
                catch(ex2, @Exception)
                begin
                    MaybeLog(1, "failed while writing error " + ex2.ToString() + " original error was " + ex.ToString())
                    Logger.Instance.CloseLog()
                end
                endtry
            end
            endtry
        endmethod

         public method DispatchOne, @object
            messageReader, @HeaderDelimitedMessageReader
            serializer, @DispatchSerializer
            callback, @CallbackDispatcher
            record
                header, ContentHeader
                jsonDoc, @object
                parsedJson, JSON_ELEMENT  
                callResponse, JSON_ELEMENT  
                result, @object
        proc
            try
            begin
                messageReader.ReadHeader(header)
                if(header.endOfConnection) then
                    mreturn ^null
                else
                begin
                    MaybeLog(5, "Dispatcher: starting client call result processing with ContentLength " + %string(header.length) + " ContentType " + %atrim(header.contentTypeBuffer))

                    ReadContent(header, messageReader, jsonDoc, parsedJson)

                    if(IS_OBJ(parsedJson)) then
                    begin
                        if(parsedJson.TryGetProperty("result", callResponse)) then
                            result = callback.HandleResponse(callResponse, this)
                        else
                            throw new Exception("json response didnt contain 'result'")
                    end
                    else
                        throw new Exception("invalid json response type")
                

                    MaybeLog(1, "Finishing call to client")
                    mreturn result
                end
            end
            catch(ex, @Exception)
            begin
                try
                begin
                    serializer.ReportError(ex.ToString(), (int)-32603, (int)-1)
                end
                catch(ex2, @Exception)
                begin
                    MaybeLog(1, "failed while writing error " + ex2.ToString() + " original error was " + ex.ToString())
                    Logger.Instance.CloseLog()
                end
                endtry
            end
            endtry
            mreturn ^null
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        public method Dispatch, void
            ttChannel, i
            record
                messageReader, @HeaderDelimitedMessageReader
                serializer, @DispatchSerializer
        proc
            messageReader = new HeaderDelimitedMessageReader(ttChannel)
            serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
            Dispatch(messageReader, serializer)
        endmethod

        public method DispatchOne, @object
            serializer, @DispatchSerializer
            callback, @CallbackDispatcher
            record
                messageReader, @HeaderDelimitedMessageReader 
                result, @object
        proc
            messageReader = new HeaderDelimitedMessageReader(serializer.CurrentOutChannel())
            result = DispatchOne(messageReader, serializer, callback)
            mreturn result
        endmethod

        class StopGuard
            serializer, @DispatchSerializer
            public UnexpectedDeconstruction, boolean
            requestId, int
            public method StopGuard
                serializer, @DispatchSerializer
                requestId, int
                endparams
            proc
                this.requestId = requestId
                this.serializer = serializer
                UnexpectedDeconstruction = true
            endmethod

            method ~StopGuard
                record
                    moduleName, a256
                    blanks, a256
                    line, int
                    i, int
                    callStack, @string
            proc
                if(UnexpectedDeconstruction)
                begin
                    callStack = ""
                    i = 1
                    clear blanks
                    xcall modname(i, moduleName, line)              ;Start with current routine
                    do
                    begin
                        callStack += " in routine " + %atrim(moduleName) + " at line " + %string(line) + ";"
                        incr i
                        xcall modname(i, moduleName, line)
                    end
                    until(moduleName .eq. blanks)

                    serializer.ReportError("Unexpected deconstruction, this indicates either stop (implicit?) or a runtime bug. Dispatching" + callStack, -32000, requestId)
                end

            endmethod
        endclass

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="jsonData"></param>
        ;;; <param name="responseChannel"></param>
        ;;; <returns></returns>
        public method ProcessCallBlock, boolean
            jsonData, JSON_ELEMENT
            serializer, @DispatchSerializer
            record
                requestId, int
                name, @string
                dispatchStub, @RoutineStub
                temp, JSON_ELEMENT
                guard, @StopGuard
            endrecord
        proc
            if(jsonData.TryGetProperty("id", temp)) then
                requestId = temp.GetInt32()
            else
                requestId = -1

            ;;grab the next highest request id
            if(requestId > MaxRequestId)
                MaxRequestId = requestId

            MaybeLog(5, "Dispatcher: requestid " + %string(requestId))

            guard = new StopGuard(serializer, requestId)

            if(jsonData.TryGetProperty("method", temp)) then
            begin
                name = temp.GetString()
            end
            else
            begin
                serializer.ReportError("method name missing", (int)-32600, requestId)
            end

            MaybeLog(5, "Dispatcher: method target was " + name)

            serializer.OutputScopeOpen()

            try
            begin
                if(name.StartsWith("rpc.")) then
                begin
                    if(name == "rpc.shutdown") then
                    begin
                        ;;we've been asked to shutdown so return false and let the outer loop take care of it
                        serializer.ReportResult(requestId, 0)
                        serializer.OutputScopeClose()
                        if(guard != ^null)
                            guard.UnexpectedDeconstruction = false
                        mreturn false
                    end
                    else if(name == "rpc.ping") then
                    begin
                        serializer.ReportResult(requestId, 0)
                    end
                    else if(name == "rpc.serializer_protocol") then
                    begin
                        serializer.ReportResult(requestId, "1.0")
                    end
                    else if(name == "rpc.set_log_level") then
                    begin
                        data paramsArray = jsonData.GetProperty("params")
                        data paramsArrayLength = paramsArray.GetArrayLength()
                        if(paramsArrayLength != 1) then
                            serializer.ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId)
                        else
                        begin
                            data settingsArgumentData = paramsArray[0]
                            data passedValue = settingsArgumentData.GetProperty("PassedValue")
                            data targetLogSettings = new LoggerScopeSettings()
                            data tempElement, JSON_ELEMENT
                            data complete = true
                            if(passedValue == ^null)
                                serializer.ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId)

                            if(passedValue.TryGetProperty("ScopeIdentifier", tempElement))
                                targetLogSettings.ScopeIdentifier = tempElement.GetString()

                            if(passedValue.TryGetProperty("LogLocation", tempElement))
                                targetLogSettings.LogLocation = tempElement.GetString()

                            if(complete = (complete && passedValue.TryGetProperty("LogToMemory", tempElement)))
                                targetLogSettings.LogToMemory = tempElement.GetBoolean()

                            if(complete = (complete && passedValue.TryGetProperty("LogToDisk", tempElement)))
                                targetLogSettings.LogToDisk = tempElement.GetBoolean()

                            if(complete = (complete && passedValue.TryGetProperty("FlushLog", tempElement)))
                                targetLogSettings.FlushLog = tempElement.GetBoolean()

                            if(complete = (complete && passedValue.TryGetProperty("OnDiskLogLevel", tempElement)))
                                targetLogSettings.OnDiskLogLevel = tempElement.GetInt32()

                            if(complete = (complete && passedValue.TryGetProperty("InMemoryLogLevel", tempElement)))
                                targetLogSettings.InMemoryLogLevel = tempElement.GetInt32()

                            if(complete = (complete && passedValue.TryGetProperty("AttachLogsToExceptions", tempElement)))
                                targetLogSettings.AttachLogsToExceptions = tempElement.GetBoolean()

                            if(!complete)
                                Logger.Instance.Log("incomplete log settings object was passed")

                            Logger.Instance.SetRootScope(targetLogSettings)

                            serializer.ReportResult(requestId, 0)
                        end

                    end
                    else if(name == "rpc.chain") then
                    begin
                        ;;TODO: flush everything out and stop chain to ourselves
                        serializer.ReportError("rpc.chain not yet implemented", -32603, requestId)
                    end
                    else
                    begin
                        ;;extension method was called but isnt supported
                        serializer.ReportError("unknown extension method", -32601, requestId)
                    end
                end
                else
                begin
                    if(mDispatchStubs.TryGet(name, dispatchStub)) then
                    begin
                        MaybeLog(5, "Dispatcher: dispatching compiled stub for " + name)
                        dispatchStub.Dispatch(name, jsonData, serializer, this)
                        MaybeLog(5, "Dispatcher: finished dispatching compiled stub for " + name)
                    end
                    else
                    begin
                        throw new RoutineNotFound(name + " was not found")
                    end
                end
                serializer.OutputScopeClose()
            end
            catch(rtnNotFound, @RoutineNotFound)
            begin
                serializer.OutputScopeAbort()
                serializer.ReportError(rtnNotFound.ToString(), -32601, requestId)
            end
            catch(ex, @Exception)
            begin
                serializer.OutputScopeAbort()
                ;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
                serializer.ReportError(ex.ToString(), -32000, requestId)
            end
            endtry
            ;;If we run this line, it means we *havent* been aborted by a rogue stop statement
            if(guard != ^null)
                guard.UnexpectedDeconstruction = false

            mreturn true
        endmethod
    endclass

    ;;; <summary>
    ;;; 
    ;;; </summary>
    abstract class RoutineStub
        public static CurrentDispatcher, @RoutineDispatcher
        public static CurrentSerializer, @DispatchSerializer

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="name"></param>
        ;;; <param name="callFrame"></param>
        ;;; <param name="serializer"></param>
        ;;; <param name="dispatcher"></param>
        protected abstract method DispatchInternal, void
            name, @string
            callFrame, JSON_ELEMENT
            serializer, @DispatchSerializer
            dispatcher, @RoutineDispatcher
        proc

        endmethod

        public method Dispatch, void
            name, @string
            callFrame, JSON_ELEMENT
            serializer, @DispatchSerializer
            dispatcher, @RoutineDispatcher
            record
                idElement, JSON_ELEMENT
                idValue, int
                hasId, boolean
        proc
            hasId = callFrame.TryGetProperty("id", idElement)
            idValue = -1
            if(hasId)
            begin
                idValue = idElement.GetInt32()
                MaybeLog(6, "prolog for id " + %string(idValue))
            end
            try
            begin
                CurrentDispatcher = dispatcher
                CurrentSerializer = serializer
                serializer.ReportResponseProlog(hasId, idValue)
                dispatcher.BeforeDispatch(name, callFrame, serializer)
                DispatchInternal(name, callFrame, serializer, dispatcher)
                dispatcher.AfterDispatch(name, callFrame, serializer)
                serializer.ReportResponseEpilog()
            end
            finally
            begin
                CurrentDispatcher = ^null
                CurrentSerializer = ^null
            end
            endtry
        endmethod

        public method RCBInit, void
            required in targetMethod, a
            required in argumentCount, int
            required inout existingHandle, D_HANDLE
        proc
            MaybeLog(5, "Dispatcher: dispatching RCB for " + targetMethod)
            if(existingHandle) then
                nop
            else
                existingHandle = %rcb_create(argumentCount, DM_STATIC)

            xcall rcb_setfnc(existingHandle, targetMethod)
        endmethod

        public method RCBOutArg, void
            index, int
            argObject, JSON_ELEMENT
            argType, FieldDataType
            inout argBuffer, a
            rcbid, D_HANDLE
            argBufferPrecision, int
            out passed, boolean
            record
                argLength, i4
                argPrecision, i4
                argValue, JSON_ELEMENT
                argEncodedProp, JSON_ELEMENT
                argIsEncoded, boolean
        proc
            RCBArgInternal(index, argObject, argType, argBuffer, rcbid, argBufferPrecision, true, passed)
        endmethod

        public method RCBArg, void
            index, int
            argObject, JSON_ELEMENT
            argType, FieldDataType
            inout argBuffer, a
            rcbid, D_HANDLE
            argBufferPrecision, int
            optional out passed, boolean
        proc
            RCBArgInternal(index, argObject, argType, argBuffer, rcbid, argBufferPrecision, false, passed)
        endmethod


        public method RCBArgInternal, void
            index, int
            argObject, JSON_ELEMENT
            argType, FieldDataType
            inout argBuffer, a
            rcbid, D_HANDLE
            argBufferPrecision, int
            alwaysPassed, boolean
            optional out passed, boolean
            record
                argLength, i4
                argPrecision, i4
                argValue, JSON_ELEMENT
                argEncodedProp, JSON_ELEMENT
                argIsEncoded, boolean
                argHasValue, boolean
        proc
            argLength = ^size(argBuffer)
            argPrecision = 0
            argHasValue = argObject.TryGetProperty("PassedValue", argValue)
            if(argHasValue || alwaysPassed) then
            begin
                if(^passed(passed))
                    passed = true

                if(argObject.TryGetProperty("ElementIsEncoded", argEncodedProp)) then
                    argIsEncoded = argEncodedProp.GetBoolean()
                else
                    argIsEncoded = false

                if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
                begin
                    data decimalPrecision, JSON_ELEMENT
                    if(argObject.TryGetProperty("DecimalPrecision", decimalPrecision))
                        argPrecision = decimalPrecision.GetInt32()

                    if(argType == FieldDataType.AlphaField || argType == FieldDataType.StringField) then
                    begin
                        if(argHasValue) then
                        begin
                            if(argIsEncoded) then
                            begin
                                argBuffer = argValue.GetStringFromBase64()
                                MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " JsonString value " + argValue.GetStringFromBase64())
                            end

                            else
                            begin
                                if(IS_TEXT(argValue)) then
                                begin
                                    argBuffer = argValue.GetString()
                                    MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " JsonString value " + argBuffer)
                                end
                                else
                                begin
                                    argBuffer = ""
                                    MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " had non string value")
                                end
                            end
                        end
                        else
                            clear argBuffer
                    end
                    else if(argType == FieldDataType.DecimalField) then
                    begin
                        if(argHasValue) then
                        begin
                            if(IS_NUMBER(argValue)) then
                            begin
                                MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " JsonNumber value " + %string(argValue.GetDecimal()))
                                ^d(argBuffer) = argValue.GetDecimal()
                            end
                            else
                                throw new Exception("Invalid argument type")
                        end
                        else
                            ^d(argBuffer) = 0
                    end
                    else if(argType == FieldDataType.ImpliedDecimalField) then
                    begin
                        if(argHasValue) then
                        begin
                            if(argValue .is. JsonNumber) then
                            begin
                                MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " JsonNumber value " + %string(argValue.GetDecimal()))
                                ^d(argBuffer, argBufferPrecision) = argValue.GetDecimal()
                            end
                            else
                                throw new Exception("Invalid argument type")
                        end
                        else
                            ^d(argBuffer, argBufferPrecision) = 0
                    end
                    else if(argType == FieldDataType.IntegerField) then
                    begin
                        if(argHasValue) then
                        begin
                            MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType)  + " and arglength " + %string(argLength) + " JsonInt value " + %string(argValue.GetInt64()))
                            ^i(argBuffer) = argValue.GetInt64()
                        end
                        else
                            ^i(argBuffer) = 0
                    end

                    else
                        throw new Exception("unexpected arg type during RCB dispatch " + %string(argType))

                    MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " argBuffer value " + argBuffer)
                    xcall rcb_setarg(rcbid, argBuffer, index, (i)argType, argLength, argPrecision)
                end
                else
                    throw new Exception("Object parameters to RCB dispatch is not currently implemented")
            end
            else
            begin
                if(^passed(passed))
                    passed = false
                MaybeLog(4, "argument " + %string(index) + " was not passed to rcb dispatcher")
            end

        endmethod
        
        public method RCBSerializeArg, void
            index, int
            passed, boolean
            argType, FieldDataType
            argBuffer, a
            argLength, i4
            argPrecision, i4
            serializer, @DispatchSerializer
        proc
            MaybeLog(4, "RCBSerializeArg: serializing argType " + %string(argType) + " marked as passed: " + %string(passed) + " with buffer " + argBuffer)

            if(passed)
            begin
                ;;alpha data can contain binary bits, if we're on pre v11 we cant encode these properly unless we let the serializer know ahead of time
                ;;this is the true/false last parameter to ArgumentData seen below
                case (argType) of
                begincase
                
                FieldDataType.AlphaField:
.ifdef DBLV11
                    serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, false)
.else
                    serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, true)
.endc
                FieldDataType.StringField:
.ifdef DBLV11
                    serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, false)
.else
                    serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, true)
.endc

                FieldDataType.IntegerField:
                    serializer.ArgumentData(index, ^i(argBuffer), argType, argLength, argPrecision, false)
                FieldDataType.ImpliedDecimalField:
                    serializer.ArgumentData(index, ^d(argBuffer, argPrecision), argType, argLength, argPrecision, false)
                FieldDataType.DecimalField:
                    serializer.ArgumentData(index, ^d(argBuffer), argType, argLength, argPrecision, false)
                endcase
            end
        endmethod
    endclass


    class SuperRoutineDispatcher extends RoutineDispatcher
        public method SuperRoutineDispatcher
            dispatchers, [#]@RoutineDispatcher
            record
                dispatcher, @RoutineDispatcher
        proc
            foreach dispatcher in dispatchers
            begin
                MergeStringDictionary(dispatcher.mDispatchStubs)
            end
        endmethod

        private method MergeStringDictionary, void
            dict, @StringDictionary
            record
                kvp, @StringDictionary.KeyValuePair
        proc
            foreach kvp in dict.Items()
            begin
                if (!mDispatchStubs.Contains(kvp.Key)) then
                begin
                    MaybeLog(5, "SuperRoutineDispatcher: adding dispatcher " + kvp.Key)
                    mDispatchStubs.Add(kvp.Key, kvp.Value)
                end
                else
                    MaybeLog(5, "SuperRoutineDispatcher: Skipping dispatcher. Already exists: " + kvp.Key)
            end

        endmethod


    endclass
endnamespace
