
import Json
import System.Collections
import TraditionalBridge

.define MaybeLog(priority, msg) if((priority) <= Logger.LogLevel) Logger.Instance.Log(msg)
;.define MaybeLog(priority, msg) Logger.Instance.Log(msg)

namespace Harmony.TraditionalBridge

    ;;; <summary>
    ;;; 
    ;;; </summary>
    public abstract class RoutineDispatcher

        ;;dummy structure for ^m operations on the mReadBuffer
        private structure MemStruct
            fld, a1
        endstructure

        protected mReadBuffer, D_HANDLE
        protected mReadBufferSize, int
        protected mDispatchStubs, @StringDictionary
        protected mActivationMask, [32]i1
        .define GetBuffer ^m(MemStruct(1:mReadBufferSize), mReadBuffer)

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        public method RoutineDispatcher
        proc
            mDispatchStubs = new StringDictionary()
            mReadBufferSize = 0
            mReadBuffer = 0
            MaybeLog(5, "Creating RoutineDispatcher")
        endmethod

        method ~RoutineDispatcher
        proc
            if(mReadBuffer != 0)
                mReadBuffer = %mem_proc(DM_FREE, mReadBuffer)

            mReadBufferSize = 0
            MaybeLog(5, "Destroying RoutineDispatcher")
        endmethod

        ;;; <summary>
        ;;; Deserialize a JSON object to a data object
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <param name="targetType">Instance of a data object metadata class indicating the type to deserialize to</param>
        ;;; <returns>A data object of the appropriate type</returns>
        public virtual method DeserializeObject, @DataObjectBase
            obj, @JsonObject
            targetType, @DataObjectMetadataBase
            record
                passedValue, @JsonObject
                objectMetadata, @DataObjectMetadataBase
                objectType, @JsonText
            endrecord
        proc
            passedValue = (@JsonObject)obj.GetProperty("PassedValue")
            objectMetadata = targetType
            if(objectMetadata == ^null)
            begin
                objectType = (@JsonText)passedValue.GetProperty("Type")
                objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
            end
            mreturn objectMetadata.Deserialize(passedValue)
        endmethod

        ;;Protocol note: this is another place where we need to decide how much we can ommit from the contents of collections
        ;;this is currently assuming we are only working with DataObjectBase

        ;;; <summary>
        ;;; Deserializes a JSON object containing a collection of serialized data objects into an ArrayList of data objects.
        ;;; Each of the data objects in the collection could be of a different type.
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <returns>ArrayList containing data objects.</returns>
        public virtual method DeserializeObjectCollection, @ArrayList
            obj, @JsonObject
            record
                passedValue, @JsonArray
                elementValue, @JsonValue
                elementObject, @JsonObject
                objectMetadata, @DataObjectMetadataBase
                objectType, @JsonText
                result, @ArrayList
                elementIsEncoded, boolean
                elementTypeValue, @JsonValue
                isBriefEncoding, boolean
            endrecord
        proc
            isBriefEncoding = false
            result = new ArrayList()
            passedValue = (@JsonArray)obj.GetProperty("PassedValue")

            obj.TryGetBoolProperty("ElementIsEncoded", elementIsEncoded)
            if(obj.TryGetProperty("ElementType", elementTypeValue))
            begin
                isBriefEncoding = true
                objectMetadata = DataObjectMetadataBase.LookupType(((@JsonText)elementTypeValue).Value)
            end

            foreach elementValue in passedValue.arrayValues
            begin
                ;;TODO might be able to skip the lookup if the typename hasnt changed
                if(!isBriefEncoding) then
                begin
                    if(elementValue .is. @JsonObject) then 
                    begin
                        elementObject = (@JsonObject)elementValue
                        objectType = (@JsonText)elementObject.GetProperty("Type")
                        objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
                        result.Add(objectMetadata.Deserialize(elementObject))
                    end
                    else if(elementValue .is. @JsonText) then
                    begin
                        result.Add(((@JsonText)elementValue).Value)
                    end
                    else if(elementValue .is. @JsonInt) then
                    begin
                        result.Add((@i)((@JsonInt)elementValue).Value)
                    end
                    else if(elementValue .is. @JsonNumber) then
                    begin
                        result.Add((@id)((@JsonNumber)elementValue).Value)
                    end
                    ;else if(elementValue .is. @JsonBoolean) then
                    ;  begin
                    ;	result.Add(((@JsonBoolean)elementValue).Value)
                    ;  end
                    else
                        throw new Exception("unknown collection encoding")
                end
                else if(elementIsEncoded) then
                begin
                    result.Add(objectMetadata.MakeNew(Convert.FromBase64String(((@JsonText)elementValue).Value), ""))
                end
                else
                begin
                    result.Add(objectMetadata.MakeNew(((@JsonText)elementValue).Value, ""))
                end
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="memoryHandle"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            memoryHandle, i4
            collection, @ArrayList
        proc
                        
        endmethod

        public method UnwrapObjectCollection, void
            dataDef, @ArgumentDataDefinition
            jsonArray, @JsonArray
            arrayList, @ArrayList
        proc

        endmethod

        ;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="buffer"></param>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="bufferPosition"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            inout buffer, a
            elementInfo, @ArgumentDataDefinition
            inout bufferPosition, i
            collection, @JsonArray
            record
                element, @JsonValue
            endrecord
        proc
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    data stringValue, @string
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = ((@JsonText)valueToken).Value
                    end
                    else
                    begin
                        stringValue = Convert.FromBase64String(((@JsonText)((@JsonObject)element).GetProperty("Base64Value")).Value)
                    end
                    buffer(bufferPosition:elementInfo.ElementSize) = stringValue
                end
                else if(element .is. JsonText) then
                begin
                    buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonText)element).Value
                end
                else if(element .is. JsonNumber) then
                begin
                    buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonNumber)element).Value
                end
                else if(element .is. JsonInt) then
                begin
                    if(elementInfo.DataType == FieldDataType.IntegerField) then
                        buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonNumber)element).Value
                    else
                        buffer(bufferPosition:elementInfo.ElementSize) = %string(((@JsonNumber)element).Value)
                end
                else if(element .is. JsonBoolean) then
                begin
                                        
                end
                else if(element .is. JsonArray)
                begin

                end
                bufferPosition += elementInfo.ElementSize
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="argument"></param>
        ;;; <returns></returns>
        public method GetArgumentDataDefForCollection, @ArgumentDataDefinition
            argument, @JsonObject
            record
                result, @ArgumentDataDefinition
                dataType, i4
            endrecord
        proc
            argument.TryGetProperty("DecimalPrecision", result.DecimalPrecision)
            argument.TryGetProperty("ElementSize", result.ElementSize)
            if(argument.TryGetProperty("DataType", dataType))
                result.DataType = (FieldDataType)dataType

            argument.TryGetBoolProperty("ReturnedValue", result.ReturnedValue)

            mreturn result

        endmethod

        ;;TODO: This needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        public method UnwrapObjectCollection, @ArrayList
            collection, @JsonArray
            record
                result, @ArrayList
        proc
            result = new ArrayList()
            UnwrapObjectCollection(collection, result)
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="collection"></param>
        ;;; <param name="targetArrayList"></param>
        public method UnwrapObjectCollection, void
            collection, @JsonArray
            targetArrayList, @ArrayList
            record
                element, @JsonValue
            endrecord
        proc
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    data stringValue, @string
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = ((@JsonText)valueToken).Value
                    end
                    else
                    begin
                        stringValue = Convert.FromBase64String(((@JsonText)((@JsonObject)element).GetProperty("Base64Value")).Value)
                    end

                    targetArrayList.Add((@a)(a)stringValue)
                end
                else if(element .is. JsonText) then
                begin
                    ;;TODO this needs to handle the arg type, could be d, id, a
                    targetArrayList.Add((@a)(a)((@JsonText)element).Value)
                end
                else if(element .is. JsonNumber) then
                begin
                    targetArrayList.Add((@id)((@JsonNumber)element).Value)
                end
                else if(element .is. JsonInt) then
                begin
                    ;;TODO this needs to handle the arg type, could be i, d, id
                    targetArrayList.Add((@i)((@JsonInt)element).Value)
                end
                else if(element .is. JsonBoolean) then
                begin
                    targetArrayList.Add((@boolean)((@JsonBoolean)element).Value)
                end
                else if(element .is. JsonArray)
                begin

                end
            end
        endmethod

        public method UnwrapStringArray, [#]@string
            collection, @JsonArray
            record
                result, [#]@string
                element, @JsonValue
                i, int
            endrecord
        proc
            i = 1
            result = new String[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonText) then
                begin
                    result[i] = ((@JsonText)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapIntArray, [#]int
            collection, @JsonArray
            record
                result, [#]int
                element, @JsonValue
                i, int
        proc
            i = 1
            result = new int[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonInt) then
                begin
                    result[i] = ((@JsonInt)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapBoolArray, [#]boolean
            collection, @JsonArray
            record
                result, [#]boolean
                element, @JsonValue
                i, int
        proc
            i = 1
            result = new boolean[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonBoolean) then
                begin
                    result[i] = ((@JsonBoolean)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapImpliedDecimalArray, [#]@id
            collection, @JsonArray
            record
                result, [#]@id
                element, @JsonValue
                i,      int
        proc
            i = 1
            result = new @id[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonNumber) then
                begin
                    result[i] = (@id)((@JsonNumber)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="serializer"></param>
        public virtual method SerializeObject, void
            obj, @DataObjectBase
            serializer, @DispatchSerializer
        proc
            obj.Serialize(serializer)
        endmethod

        ;;Protocol note: its not entirely decided how explicit we need to be about types for things
        ;;most things in synergy dont jump from one primative type to another
        ;;its possible for this to happen with an arraylist but this might be an acceptable tradoff for the significant protocol efficiancy gains
        ;;in only specifying the element type once

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="serializer"></param>
        public virtual method SerializeObjectCollection, void
            obj, @ArrayList
            serializer, @DispatchSerializer
            record
                doElement, @DataObjectBase
                primativeElement, @object
            endrecord
        proc
            ;;determine the collection type from the first element type then serialize assuming we dont switch between primatives and objects
            serializer.ArrayOpen()
            if(obj.Count > 0)
            begin
                if(obj[0] .is. @DataObjectBase) then
                begin
                    foreach doElement in obj
                    begin
                        doElement.Serialize(serializer)
                    end
                end
                else
                begin
                    ;;this should encode something like this
                    ;;serializer.String("ElementSize")
                    ;;serializer.Int(^size(unboxedElement))
                    ;;get the unboxed type and put that in as serializer.String("ElementType")
                    throw new Exception("primative arrays not yet supported")
                end
            end
            serializer.ArrayClose()
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetText, a
            value, @JsonObject
            record
                valueText, @JsonText
            endrecord
        proc
            valueText = (@JsonText)value.GetProperty("PassedValue")
            mreturn valueText.Value
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetInt, i
            value, @JsonObject
            record
                valueInt, @JsonInt
            endrecord
        proc
            valueInt = (@JsonInt)value.GetProperty("PassedValue")
            mreturn valueInt.Value
        endmethod

        public method GetArray, @JsonArray
            value, @JsonObject
            record
                valueArray, @JsonArray
            endrecord
        proc
            valueArray = (@JsonArray)value.GetProperty("PassedValue")
            mreturn valueArray
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetDecimal, d
            value, @JsonObject
            record
                passedValue, @JsonValue
                valueInt, @JsonInt
                valuestring, @JsonText
                tempD, d28
            endrecord
        proc
            passedValue = value.GetProperty("PassedValue")
            if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
            begin
                valueInt = (@JsonInt)passedValue
                tempD = valueInt.Value
                mreturn tempD
            end
            else
            begin
                valuestring = (@JsonText)passedValue
                mreturn ^d((a)valuestring.Value)
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetImplied, d.
            value, @JsonObject
            record
                passedValue, @JsonValue
                valueInt, @JsonInt
                precisionValue, @JsonValue
                precisionInt, @JsonInt
                valuestring, @JsonText
                tempD, d56.28
            endrecord
        proc
            passedValue = value.GetProperty("PassedValue")

            precisionValue = value.GetProperty("DecimalPrecision")
            precisionInt = (@JsonInt)precisionValue

            if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
            begin
                valueInt = (@JsonInt)passedValue
                tempD = ^d(%string(valueInt.Value),precisionInt.Value)
                mreturn tempD
            end
            else
            begin
                valuestring = (@JsonText)passedValue
                mreturn %implied((a)valuestring.Value)
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="serializer"></param>
        public method SerializeObject, void
            obj, @object
            serializer, @DispatchSerializer
        proc
            if(obj .is. @DataObjectBase) then
                SerializeObject((@DataObjectBase)obj, serializer)
            else if(obj .is. @ArrayList) then
                SerializeObjectCollection((@ArrayList)obj, serializer)
            else if(obj .is. @a || obj .is. @d || obj .is. @id || obj .is. @string) then
                serializer.String(obj.ToString())
            else if(obj .is. @i) then
                serializer.Integer((i)obj)
            else
                throw new Exception("Attempted to serialize an unknown object type")
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="dataType"></param>
        ;;; <returns></returns>
        public method DeserializeObject, @object
            obj, @JsonObject
            out dataType, FieldDataType
            record
                dataTypeInt, @JsonInt
                propValue, @JsonValue
            endrecord
        proc
            dataTypeInt = ((@JsonInt)obj.GetProperty("DataType"))
            dataType = (FieldDataType)dataTypeInt.Value
            if(dataType == FieldDataType.DataObjectField) then
            begin
                mreturn DeserializeObject(obj, ^null)
            end
            else if(dataType == FieldDataType.DataObjectCollectionField) then
            begin
                mreturn DeserializeObjectCollection(obj)
            end
            else
            begin
                obj.TryGetProperty("PassedValue", propValue)
                if(dataType == FieldDataType.AlphaField) then
                begin
                    if(propValue == ^null) then
                        mreturn (@object)""
                    else
                    begin
                        data textObject, @JsonText, ((@JsonText)propValue)
                        mreturn textObject.Value
                    end
                end
                else if(dataType == FieldDataType.DecimalField) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn ((@JsonText)propValue).Value
                    end
                end
                else if(dataType == FieldDataType.ImpliedDecimal) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn ((@JsonText)propValue).Value
                    end
                end
                else if(dataType == FieldDataType.IntegerField)
                begin
                    data intValue, i4, 0
                    if(propValue != ^null)
                        intValue = ((@JsonInt)propValue).Value
                                
                    mreturn (@object)intValue
                end
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        ;;; <param name="frameHeader"></param>
        ;;; <returns></returns>
        private method ReadCallBlock, boolean
            required in ttChannel, i
            required in frameHeader, i4
            required in leftovers, a
            required in leftoversLength, i
            record
                jsonReader, @Json
                parsedJson, @JsonValue
                serializer, @DispatchSerializer
                result, boolean
                readerPosition, int
                remainingRead, int
            endrecord
        proc
            jsonReader = new Json()
            serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
            ;;reuse the same buffer if possible
            if(mReadBufferSize < frameHeader)
            begin
                if(mReadBuffer != 0) then
                begin
                    MaybeLog(6, "Dispatcher: reallocating buffer was " + %string(mReadBufferSize) + " -> " + %string(frameHeader) )
                    mReadBuffer = %mem_proc(DM_RESIZ, frameHeader, mReadBuffer)
                    mReadBufferSize = frameHeader
                end
                else
                begin
                    MaybeLog(6, "Dispatcher: allocating buffer with length" + %string(frameHeader))
                    mReadBuffer = %mem_proc(DM_ALLOC | DM_STATIC, frameHeader)
                    mReadBufferSize = frameHeader
                end
            end

            MaybeLog(6, "Dispatcher: Reading " + %string(frameHeader) + " total bytes of Content from input" )
            readerPosition = 1 + leftoversLength
            remainingRead = frameHeader - leftoversLength

            if(leftoversLength > 0)
            begin
                ;;workaround for non conforming io on newlines
                decr(remainingRead)
                ^m(MemStruct(1:leftoversLength), mReadBuffer) = leftovers(1:leftoversLength)
            end


            do 
            begin
                MaybeLog(6, "Dispatcher: Reading " + %string(remainingRead) + " bytes from input")
                gets(ttChannel, ^m(MemStruct(readerPosition:remainingRead), mReadBuffer), wait:100, MASK:mActivationMask) [$ERR_TIMOUT=again]
            again,  
                MaybeLog(6, "Dispatcher: Reading Content from input" + ^m(MemStruct(readerPosition:remainingRead), mReadBuffer) + ": got " + %string(%rdlen(ttChannel)) + " bytes, was expecting " + %string(remainingRead) + " bytes")
                readerPosition += %rdlen(ttChannel)
                remainingRead = frameHeader - readerPosition
                                
            end
            until remainingRead <= 0

            MaybeLog(6, "Dispatcher: Parsing buffer " + ^m(MemStruct(1:frameHeader), mReadBuffer))
            parsedJson = jsonReader.ParseJson(^m(MemStruct(1:readerPosition - 1), mReadBuffer))

            if (!(parsedJson .is. @JsonObject) && !(parsedJson .is. @JsonArray))
            begin
                ReportError("failed to parse json request", (int)-32700, (int)-1, serializer)
                mreturn true
            end

            MaybeLog(5, "Dispatcher: Finished Json Parsing")

            result = true
            if(parsedJson .is. JsonObject) then
            begin
                MaybeLog(5, "Dispatcher: Single Call")
                result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
            end
            else if(parsedJson .is. JsonArray)
            begin
                data parsedArray, @JsonArray
                data jsonVal, @JsonValue
                parsedArray = (@JsonArray)parsedJson

                MaybeLog(5, "Dispatcher: Batch Call")

                serializer.ArrayOpen()
                foreach jsonVal in parsedArray.arrayValues
                begin
                    if(jsonVal .is. JsonObject) then
                    begin
                        result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
                        if(!result)
                            exitloop
                    end
                    else
                    begin
                        ReportError("failed to parse json request", (int)-32700, (int)-1, serializer)
                    end
                end
                serializer.ArrayClose()
            end

            flush(ttChannel)
            mreturn result

        endmethod

        public method ReportError, void
            errorText, @string
            errorCode, int
            messageId, int
            serializer, @DispatchSerializer
            record
                scopeLog, @ArrayList
                loggerSettings, @LoggerScopeSettings
        proc
            serializer.OutputScopeAbort()
                        
            if(messageId != -1) then
            begin
                serializer.MapOpen()
                serializer.Pair("jsonrpc", "2.0")
                serializer.String("error")
                serializer.MapOpen()
                serializer.Pair("code", errorCode)

                serializer.Pair("message", Convert.ToBase64String(errorText))

                ;;if scope logging is active return everything that was logged as part of this request scope
                if(Logger.Instance.ShouldAttachLogsToExceptions)
                begin
                    scopeLog = Logger.Instance.CurrentScopeLog()
                    if(scopeLog != ^null && scopeLog.Count > 0)
                    begin
                                                
                        data logEntry, @string
                        MaybeLog(2, "Dispatcher: attaching in memory logs to thrown exception")

                        serializer.MapOpen("data")
                        serializer.String("logs")
                        serializer.ArrayOpen()

                        foreach logEntry in scopeLog as @String
                        begin
                            serializer.String(Convert.ToBase64String(logEntry))
                        end

                        serializer.ArrayClose()

                        loggerSettings = Logger.Instance.CurrentLogSettings()

                        serializer.MapOpen("log_settings")
                        serializer.Pair("ScopeIdentifier", loggerSettings.ScopeIdentifier)
                        serializer.PairBool("LogToMemory", loggerSettings.LogToMemory)
                        serializer.PairBool("LogToDisk", loggerSettings.LogToDisk)
                        serializer.Pair("LogLocation", loggerSettings.LogLocation)
                        serializer.PairBool("FlushLog", loggerSettings.FlushLog)
                        serializer.Pair("OnDiskLogLevel", loggerSettings.OnDiskLogLevel)
                        serializer.Pair("InMemoryLogLevel", loggerSettings.InMemoryLogLevel)
                        serializer.PairBool("AttachLogsToExceptions", loggerSettings.AttachLogsToExceptions)
                        serializer.MapClose()

                        serializer.MapClose()
                    end
                end

                serializer.MapClose()

                if(messageId > -1) then
                    serializer.Pair("id", messageId)
                else
                    serializer.PairNull("id")

                serializer.MapClose()

                MaybeLog(1, "ReportError: " + errorText + " messageId" + %string(messageId))
            end
            else
            begin
                MaybeLog(5, "ReportError: Notify -> " + errorText)
            end
        endmethod

        public method ReportResult, void
            requestId, int
            result, @string
            serializer, @DispatchSerializer
        proc
            if(requestId != -1) then
            begin
                serializer.MapOpen()
                serializer.Pair("jsonrpc", "2.0")
                serializer.Pair("result", result)
                        
                if(requestId > -1) then
                    serializer.Pair("id", requestId)
                else
                    serializer.PairNull("id")

                serializer.MapClose()

                MaybeLog(5, "ReportResult: " + result + " messageId" + %string(requestId))
            end
            else
            begin
                MaybeLog(5, "ReportResult: Notify")
            end

        endmethod

        public method ReportResult, void
            requestId, int
            result, n
            serializer, @DispatchSerializer
        proc
            if(requestId != -1) then
            begin
                serializer.MapOpen()
                serializer.Pair("jsonrpc", "2.0")
                serializer.Pair("result", result)
                        
                if(requestId > -1) then
                    serializer.Pair("id", requestId)
                else
                    serializer.PairNull("id")

                serializer.MapClose()
                MaybeLog(5, "ReportResult: " + %string(result) + " messageId" + %string(requestId))
            end
            else
            begin
                MaybeLog(5, "ReportResult: Notify")
            end
        endmethod

		public method ReportResult, void
			requestId, int
			result, [#]@object
			inputSet, [#]boolean
			resultTypes, [#]FieldDataType
			serializer, @DispatchSerializer
			record
				arg, @object
				ii, int
		proc
				serializer.ArrayOpen()
				ii = 0
				foreach arg in result
				begin
					incr ii
					if(inputSet[ii])
					begin
						serializer.ArgumentData(ii, arg, 
					end
				end
				MaybeLog(5, "ReportResult: array(" + %string(result.Length) + ") messageId" + %string(requestId))
			
		endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        public method Dispatch, void
            ttChannel, i
            record PacketLength
                contentLengthPart, a16
                lengthValue, a10
                padding, a2
            endrecord
            record ContentType
                contentTypeBuffer, a255
            endrecord
            record
                leftoverData, a1
                leftoverLength, int
                lengthReadPos, int
            record
                running, boolean
                frameHeader, d10
                contentTypePos, int
                contentTypeLength, int
            endrecord
        proc
            ;;read 10 bytes of data from input when its available
            ;;read count of bytes from input (in chunks ideally) 
            ;;look for the target routine name
            ;;build rcb block for the call
            ;;deserialize arguments based on the types in json
            ;;make the call
            ;;trap any exceptions
            try
            begin
                running = true
                while(running)
                begin
                    clear ContentType
                    clear PacketLength
                    lengthReadPos = 1
                    do 
                    begin
                        gets(ttChannel, PacketLength(lengthReadPos:1), wait:100, MASK:mActivationMask)  [$ERR_TIMOUT=again]
                        contentTypeLength = %rdlen(ttChannel)
                                                                                                
                        if(contentTypeLength != 1)
                            MaybeLog(5, "Dispatcher: got zero length from single char read without timeout")
                                                                                                
                        lengthReadPos += contentTypeLength
                    again,          
                        MaybeLog(6, "Dispatcher: Reading ContentLength from input" + %atrim(PacketLength) + ":" + %string(lengthReadPos))
                    end
                    until lengthReadPos > 16 && PacketLength(lengthReadPos - 1:1) == %char(10)
                    clear PacketLength(lengthReadPos - 2:2)
                    frameHeader = ^d(%atrim(lengthValue))
                    contentTypePos = 1
                    while(contentTypePos < 255)
                    begin
                    againContent,   
                        gets(ttChannel, ContentType(contentTypePos:1), wait:100, MASK:mActivationMask)  [$ERR_TIMOUT=againContent]
                        ;;if(contentTypePos > 3 && ContentType(contentTypePos:1) == %char(10))
                        ;;begin
                        ;;        leftoverLength = 0
                        ;;        exitloop
                        ;;end

                        if(ContentType(contentTypePos:1) == '{')
                        begin
                            leftoverData = '{'
                            leftoverLength = 1
                            exitloop
                        end

                        contentTypePos += %rdlen(ttChannel)
                    end

                    MaybeLog(6, "Dispatcher: Reading ContentType from input" + %atrim(ContentType) + ":" + %string(contentTypePos))

                    MaybeLog(5, "Dispatcher: starting callblock processing with ContentLength " + %atrim(lengthValue) + " ContentType " + %atrim(ContentType))

                    running = ReadCallBlock(ttChannel, (int)frameHeader + 1, leftoverData, leftoverLength)
                end
                writes(ttChannel, "Shutting down due to running == false")
            end
            catch(ex, @Exception)
            begin
                try
                begin
                    data serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
                    ReportError(ex.ToString(), (int)-32603, (int)-1, serializer)
                end
                catch(ex2, @Exception)
                begin
                    MaybeLog(1, "failed while writing error " + ex2.ToString() + " original error was " + ex.ToString())
                    Logger.Instance.CloseLog()
                end
                endtry
            end
            endtry
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="jsonData"></param>
        ;;; <param name="responseChannel"></param>
        ;;; <returns></returns>
        public method ProcessCallBlock, boolean
            jsonData, @JsonObject
            serializer, @DispatchSerializer
            record
                requestId, int
                name, @string
                argArrayList, @ArrayList
                dispatchStub, @RoutineStub
            endrecord
        proc
                        
            if(!jsonData.TryGetProperty("id", requestId))
                requestId = -1

            if(!jsonData.TryGetProperty("method", name))
            begin
                ReportError("method name missing", (int)-32600, requestId, serializer)
            end

            MaybeLog(5, "Dispatcher: method target was " + name)

            serializer.OutputScopeOpen()

            try
            begin
                if(name.StartsWith("rpc.")) then
                begin
                    if(name == "rpc.shutdown") then
                    begin
                        ;;we've been asked to shutdown so return false and let the outer loop take care of it
                        ReportResult(requestId, 0, serializer)
                        serializer.OutputScopeClose()
                        mreturn false
                    end
                    else if(name == "rpc.ping") then
                    begin
                        ReportResult(requestId, 0, serializer)
                    end
                    else if(name == "rpc.serializer_protocol") then
                    begin
                        ReportResult(requestId, "1.0", serializer)
                    end
                    else if(name == "rpc.set_log_level") then
                    begin
                        data logArg, @JsonInt
                        argArrayList = ((@JsonArray)jsonData.GetProperty("params")).arrayValues

                        if(argArrayList.Count != 1 || !(argArrayList[0] .is. JsonObject)) then
                            ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId, serializer)
                        else
                        begin
                            data settingsArgumentData = (@JsonObject)argArrayList[0] 
                            data passedValueProp = settingsArgumentData.GetProperty("PassedValue")
                            data passedValue = (@JsonObject)passedValueProp
                            data targetLogSettings = new LoggerScopeSettings()
                            if(passedValue == ^null)
                                ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId, serializer)

                            passedValue.TryGetProperty("ScopeIdentifier", targetLogSettings.ScopeIdentifier)
                            passedValue.TryGetProperty("LogLocation", targetLogSettings.LogLocation)
                            if(!(passedValue.TryGetBoolProperty("LogToMemory", targetLogSettings.LogToMemory) &&
                            &    passedValue.TryGetBoolProperty("LogToDisk", targetLogSettings.LogToDisk) &&
                            &    passedValue.TryGetBoolProperty("FlushLog", targetLogSettings.FlushLog) &&
                            &    passedValue.TryGetProperty("OnDiskLogLevel", targetLogSettings.OnDiskLogLevel) &&
                            &    passedValue.TryGetProperty("InMemoryLogLevel", targetLogSettings.InMemoryLogLevel) &&
                            &    passedValue.TryGetBoolProperty("AttachLogsToExceptions", targetLogSettings.AttachLogsToExceptions)))
                                Logger.Instance.Log("incomplete log settings object was passed")

                            Logger.Instance.SetRootScope(targetLogSettings)

                            ReportResult(requestId, 0, serializer)
                        end

					end
					else if(name == "rpc.chain") then
					begin
						;;TODO: flush everything out and stop chain to ourselves
						ReportError("rpc.chain not yet implemented", -32603, requestId, serializer)
					end
					else
					begin
						;;extension method was called but isnt supported
						ReportError("unknown extension method", -32601, requestId, serializer)
					end
				end
				else
				begin
					if(mDispatchStubs.TryGet(name, dispatchStub)) then
					begin
						MaybeLog(5, "Dispatcher: dispatching compiled stub for " + name)
						dispatchStub.Dispatch(name, jsonData, serializer, this)
						MaybeLog(5, "Dispatcher: finished dispatching compiled stub for " + name)
					end
					else
					begin
						throw new RoutineNotFound(name + " was not found")
					end
				end
				serializer.OutputScopeClose()
			end
			catch(rtnNotFound, @RoutineNotFound)
			begin
				serializer.OutputScopeAbort()
				ReportError(rtnNotFound.ToString(), -32601, requestId, serializer)
			end
			catch(ex, @Exception)
			begin
				serializer.OutputScopeAbort()
				;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
				ReportError(ex.ToString(), -32000, requestId, serializer)
			end
			endtry

			mreturn true
		endmethod

		public method RCBInit, void
			required in targetMethod, a
			required in argumentCount, int
			required inout existingHandle, D_HANDLE
		proc
			MaybeLog(5, "Dispatcher: dispatching dynamically for " + targetMethod)
			if(existingHandle) then
				existingHandle = %rcb_create(argumentCount, DM_STATIC, existingHandle) 
			else
				existingHandle = %rcb_create(argumentCount, DM_STATIC)

			xcall rcb_setfnc(rcbid, name)
		endmethod

		public method RCBArg, void
			index, int
			argObject, @JsonObject
			argType, FieldDataType
			argBuffer, a
			record
				argLength, i4
				argPrecision, i4
		proc
			argLength = 0
			argPrecision = 0

			if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
			begin
				data elementSizeValue, @JsonValue
				if(jsonData.HasProperty("DecimalPrecision"))
					argPrecision = ((@JsonInt)jsonData.GetProperty("DecimalPrecision")).Value

				if(jsonData.TryGetProperty("ElementSize", elementSizeValue)) then
					argLength = ((@JsonInt)elementSizeValue).Value
				else
					argLength = ^size((argBuffer)

				xcall rcb_setarg(rcbid, (n)argBuffer, ii, (i)argType, argLength, argPrecision)
			end
			else
				throw new Exception("Object parameters to RCB dispatch is not currently implemented")
		endmethod

		public 
		
		public method RCBSerializeArg, void
			index, int
			argType, FieldDataType
			argBuffer, a
			argLength, i4
			argPrecision, i4
			serializer, @DispatchSerializer
		proc
			case (argType) of
			begincase
			FieldDataType.AlphaField:
				serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, false)
			FieldDataType.IntegerField:
				serializer.ArgumentData(index, ^i(argBuffer), argType, argLength, argPrecision, false)
			FieldDataType.ImpliedDecimalField:
				serializer.ArgumentData(index, ^d(argBuffer, argPrecision), argType, argLength, argPrecision, false)
			FieldDataType.DecimalField:
				serializer.ArgumentData(index, ^d(argBuffer), argType, argLength, argPrecision, false)
			endcase
		endmethod


	endclass

    ;;; <summary>
    ;;; 
    ;;; </summary>
    abstract class RoutineStub
                
        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="name"></param>
        ;;; <param name="callFrame"></param>
        ;;; <param name="serializer"></param>
        ;;; <param name="dispatcher"></param>
        protected abstract method DispatchInternal, void
            name, @string
            callFrame, @JsonObject
            serializer, @DispatchSerializer
            dispatcher, @RoutineDispatcher
        proc

        endmethod

        public method Dispatch, void
            name, @string
            callFrame, @JsonObject
            serializer, @DispatchSerializer
            dispatcher, @RoutineDispatcher
            record
                requestId, int
        proc
            serializer.MapOpen()
            serializer.Pair("jsonrpc", "2.0")

            if(callFrame.TryGetProperty("id", requestId)) then
                serializer.Pair("id", requestId)
            else
                serializer.PairNull("id")

            serializer.String("result")
            serializer.ArrayOpen()

            DispatchInternal(name, callFrame, serializer, dispatcher)

            ;;Terminate the "ReturnParameters" array
            serializer.ArrayClose()

            ;;Terminate the "Result" object
            serializer.MapClose()
            ;;Terminate the response object
            serializer.MapClose()
        endmethod
    endclass


    class SuperRoutineDispatcher extends RoutineDispatcher
        public method SuperRoutineDispatcher
            dispatchers, [#]@RoutineDispatcher
            record
                dispatcher, @RoutineDispatcher
        proc
            foreach dispatcher in dispatchers
            begin
                MergeStringDictionary(dispatcher.mDispatchStubs)
            end
        endmethod

        private method MergeStringDictionary, void
            dict, @StringDictionary
            record
                kvp, @StringDictionary.KeyValuePair
        proc
            foreach kvp in dict.Items()
            begin
                MaybeLog(5, "SuperRoutineDispatcher: adding dispatcher " + kvp.Key)
                mDispatchStubs.Add(kvp.Key, kvp.Value)
            end

        endmethod


    endclass
endnamespace
