
import Json
import System.Collections
import TraditionalBridge

.define MaybeLog(priority, msg) if((priority) <= Logger.LogLevel) Logger.Instance.Log(msg)

namespace Harmony.TraditionalBridge

	;;; <summary>
	;;; 
	;;; </summary>
	public abstract class RoutineDispatcher

		;;dummy structure for ^m operations on the mReadBuffer
		private structure MemStruct
			fld, a1
		endstructure

		protected mReadBuffer, D_HANDLE
		protected mReadBufferSize, int
		protected mDispatchStubs, @StringDictionary
		protected mActivationMask, [32]i1
.define GetBuffer ^m(MemStruct(1:mReadBufferSize), mReadBuffer)

		;;; <summary>
		;;; Constructor
		;;; </summary>
		public method RoutineDispatcher
		proc
			mDispatchStubs = new StringDictionary()
			mReadBufferSize = 0
			mReadBuffer = 0
			MaybeLog(5, "Creating RoutineDispatcher")
		endmethod

		method ~RoutineDispatcher
		proc
			if(mReadBuffer != 0)
				mReadBuffer = %mem_proc(DM_FREE, mReadBuffer)

			mReadBufferSize = 0
			MaybeLog(5, "Destroying RoutineDispatcher")
		endmethod

		;;; <summary>
		;;; Deserialize a JSON object to a data object
		;;; </summary>
		;;; <param name="obj">JSON object to deserialize</param>
		;;; <param name="targetType">Instance of a data object metadata class indicating the type to deserialize to</param>
		;;; <returns>A data object of the appropriate type</returns>
		public virtual method DeserializeObject, @DataObjectBase
			obj, @JsonObject
			targetType, @DataObjectMetadataBase
			record
				passedValue, @JsonObject
				objectMetadata, @DataObjectMetadataBase
				objectType, @JsonText
			endrecord
		proc
			passedValue = (@JsonObject)obj.GetProperty("PassedValue")
			objectMetadata = targetType
			if(objectMetadata == ^null)
			begin
				objectType = (@JsonText)passedValue.GetProperty("Type")
				objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
			end
			mreturn objectMetadata.Deserialize(passedValue)
		endmethod

		;;Protocol note: this is another place where we need to decide how much we can ommit from the contents of collections
		;;this is currently assuming we are only working with DataObjectBase

		;;; <summary>
		;;; Deserializes a JSON object containing a collection of serialized data objects into an ArrayList of data objects.
		;;; Each of the data objects in the collection could be of a different type.
		;;; </summary>
		;;; <param name="obj">JSON object to deserialize</param>
		;;; <returns>ArrayList containing data objects.</returns>
		public virtual method DeserializeObjectCollection, @ArrayList
			obj, @JsonObject
			record
				passedValue, @JsonArray
				elementValue, @JsonObject
				objectMetadata, @DataObjectMetadataBase
				objectType, @JsonText
				result, @ArrayList
			endrecord
		proc
			result = new ArrayList()
			passedValue = (@JsonArray)obj.GetProperty("PassedValue")
			foreach elementValue in passedValue.arrayValues
			begin
				;;TODO might be able to skip the lookup if the typename hasnt changed
				objectType = (@JsonText)elementValue.GetProperty("Type")
				objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
				result.Add(objectMetadata.Deserialize(elementValue))
			end
			mreturn result
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="memoryHandle"></param>
		;;; <param name="collection"></param>
		public method UnwrapObjectCollection, void
			memoryHandle, i4
			collection, @ArrayList
		proc
			
		endmethod

		;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="buffer"></param>
		;;; <param name="elementInfo"></param>
		;;; <param name="bufferPosition"></param>
		;;; <param name="collection"></param>
		public method UnwrapObjectCollection, void
			inout buffer, a
			elementInfo, @ArgumentDataDefinition
			inout bufferPosition, i
			collection, @JsonArray
			record
				element, @JsonValue
			endrecord
		proc
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonObject) then
				begin
					data stringValue = ((@JsonText)((@JsonObject)element).GetProperty("Value")).Value
					buffer(bufferPosition:elementInfo.ElementSize) = stringValue
				end
				else if(element .is. JsonText) then
				begin
					buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonText)element).Value
				end
				else if(element .is. JsonNumber) then
				begin
					buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonNumber)element).Value
				end
				else if(element .is. JsonInt) then
				begin
					if(elementInfo.DataType == FieldDataType.IntegerField) then
						buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonNumber)element).Value
					else
						buffer(bufferPosition:elementInfo.ElementSize) = %string(((@JsonNumber)element).Value)
				end
				else if(element .is. JsonBoolean) then
				begin
					
				end
				else if(element .is. JsonArray)
				begin

				end
				bufferPosition += elementInfo.ElementSize
			end

		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="argument"></param>
		;;; <returns></returns>
		public method GetArgumentDataDefForCollection, @ArgumentDataDefinition
			argument, @JsonObject
			record
				result, @ArgumentDataDefinition
				dataType, i4
			endrecord
		proc
			argument.TryGetProperty("DecimalPrecision", result.DecimalPrecision)
			argument.TryGetProperty("ElementSize", result.ElementSize)
			if(argument.TryGetProperty("DataType", dataType))
				result.DataType = (FieldDataType)dataType

			argument.TryGetBoolProperty("ReturnedValue", result.ReturnedValue)

			mreturn result

		endmethod

		;;TODO: This needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

		public method UnwrapObjectCollection, @ArrayList
			collection, @JsonArray
			record
				result, @ArrayList
		proc
			result = new ArrayList()
			UnwrapObjectCollection(collection, result)
			mreturn result
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="elementInfo"></param>
		;;; <param name="collection"></param>
		;;; <param name="targetArrayList"></param>
		public method UnwrapObjectCollection, void
			collection, @JsonArray
			targetArrayList, @ArrayList
			record
				element, @JsonValue
			endrecord
		proc
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonObject) then
				begin
					data stringValue = ((@JsonText)((@JsonObject)element).GetProperty("Value")).Value
					targetArrayList.Add((@a)(a)stringValue)
				end
				else if(element .is. JsonText) then
				begin
					;;TODO this needs to handle the arg type, could be d, id, a
					targetArrayList.Add((@a)(a)((@JsonText)element).Value)
				end
				else if(element .is. JsonNumber) then
				begin
					targetArrayList.Add((@id)((@JsonNumber)element).Value)
				end
				else if(element .is. JsonInt) then
				begin
					;;TODO this needs to handle the arg type, could be i, d, id
					targetArrayList.Add((@i)((@JsonInt)element).Value)
				end
				else if(element .is. JsonBoolean) then
				begin
					targetArrayList.Add((@boolean)((@JsonBoolean)element).Value)
				end
				else if(element .is. JsonArray)
				begin

				end
			end
		endmethod

		public method UnwrapStringArray, [#]@string
			collection, @JsonArray
			record
				result, [#]@string
				element, @JsonValue
				i, int
			endrecord
		proc
			i = 1
			result = new String[collection.arrayValues.Count]
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonText) then
				begin
					result[i] = ((@JsonText)element).Value
				end
				else
					throw new InvalidCastException()
				incr i
			end
			mreturn result
		endmethod

		public method UnwrapIntArray, [#]int
			collection, @JsonArray
			record
				result, [#]int
				element, @JsonValue
				i, int
		proc
			i = 1
			result = new int[collection.arrayValues.Count]
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonInt) then
				begin
					result[i] = ((@JsonInt)element).Value
				end
				else
					throw new InvalidCastException()
				incr i
			end
			mreturn result
		endmethod

		public method UnwrapBoolArray, [#]boolean
			collection, @JsonArray
		record
			result, [#]boolean
			element, @JsonValue
			i, int
		proc
			i = 1
			result = new boolean[collection.arrayValues.Count]
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonBoolean) then
				begin
					result[i] = ((@JsonBoolean)element).Value
				end
				else
					throw new InvalidCastException()
				incr i
			end
			mreturn result
		endmethod

		public method UnwrapImpliedDecimalArray, [#]@id
			collection, @JsonArray
		record
			result, [#]@id
			element, @JsonValue
			i,	int
		proc
			i = 1
			result = new @id[collection.arrayValues.Count]
			foreach element in collection.arrayValues
			begin
				if(element .is. JsonNumber) then
				begin
					result[i] = (@id)((@JsonNumber)element).Value
				end
				else
					throw new InvalidCastException()
				incr i
			end
			mreturn result
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="obj"></param>
		;;; <param name="serializer"></param>
		public virtual method SerializeObject, void
			obj, @DataObjectBase
			serializer, @DispatchSerializer
		proc
			obj.Serialize(serializer)
		endmethod

		;;Protocol note: its not entirely decided how explicit we need to be about types for things
		;;most things in synergy dont jump from one primative type to another
		;;its possible for this to happen with an arraylist but this might be an acceptable tradoff for the significant protocol efficiancy gains
		;;in only specifying the element type once

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="obj"></param>
		;;; <param name="serializer"></param>
		public virtual method SerializeObjectCollection, void
			obj, @ArrayList
			serializer, @DispatchSerializer
			record
				doElement, @DataObjectBase
				primativeElement, @object
			endrecord
		proc
			;;determine the collection type from the first element type then serialize assuming we dont switch between primatives and objects
			serializer.ArrayOpen()
			if(obj.Count > 0)
			begin
				if(obj[0] .is. @DataObjectBase) then
				begin
					foreach doElement in obj
					begin
						doElement.Serialize(serializer)
					end
				end
				else
				begin
					;;this should encode something like this
					;;serializer.String("ElementSize")
					;;serializer.Int(^size(unboxedElement))
					;;get the unboxed type and put that in as serializer.String("ElementType")
					throw new Exception("primative arrays not yet supported")
				end
			end
			serializer.ArrayClose()
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="value"></param>
		;;; <returns></returns>
		public method GetText, a
			value, @JsonObject
			record
				valueText, @JsonText
			endrecord
		proc
			valueText = (@JsonText)value.GetProperty("PassedValue")
			mreturn valueText.Value
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="value"></param>
		;;; <returns></returns>
		public method GetInt, i
			value, @JsonObject
			record
				valueInt, @JsonInt
			endrecord
		proc
			valueInt = (@JsonInt)value.GetProperty("PassedValue")
			mreturn valueInt.Value
		endmethod

		public method GetArray, @JsonArray
			value, @JsonObject
			record
				valueArray, @JsonArray
			endrecord
		proc
			valueArray = (@JsonArray)value.GetProperty("PassedValue")
			mreturn valueArray
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="value"></param>
		;;; <returns></returns>
		public method GetDecimal, d
			value, @JsonObject
			record
				passedValue, @JsonValue
				valueInt, @JsonInt
				valuestring, @JsonText
				tempD, d28
			endrecord
		proc
			passedValue = value.GetProperty("PassedValue")
			if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
			begin
				valueInt = (@JsonInt)passedValue
				tempD = valueInt.Value
				mreturn tempD
			end
			else
			begin
				valuestring = (@JsonText)passedValue
				mreturn ^d((a)valuestring.Value)
			end
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="value"></param>
		;;; <returns></returns>
		public method GetImplied, d.
			value, @JsonObject
			record
				passedValue, @JsonValue
				valueInt, @JsonInt
				precisionValue, @JsonValue
				precisionInt, @JsonInt
				valuestring, @JsonText
				tempD, d56.28
			endrecord
		proc
			passedValue = value.GetProperty("PassedValue")

			precisionValue = value.GetProperty("DecimalPrecision")
			precisionInt = (@JsonInt)precisionValue

			if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
			begin
				valueInt = (@JsonInt)passedValue
				tempD = ^d(%string(valueInt.Value),precisionInt.Value)
				mreturn tempD
			end
			else
			begin
				valuestring = (@JsonText)passedValue
				mreturn ^d((a)valuestring.Value,precisionInt.Value)
			end
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="obj"></param>
		;;; <param name="serializer"></param>
		public method SerializeObject, void
			obj, @object
			serializer, @DispatchSerializer
		proc
			if(obj .is. @DataObjectBase) then
				SerializeObject((@DataObjectBase)obj, serializer)
			else if(obj .is. @ArrayList) then
				SerializeObjectCollection((@ArrayList)obj, serializer)
			else if(obj .is. @a || obj .is. @d || obj .is. @id || obj .is. @string) then
				serializer.String(obj.ToString())
			else if(obj .is. @i) then
				serializer.Integer((i)obj)
			else
				throw new Exception("Attempted to serialize an unknown object type")
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="obj"></param>
		;;; <param name="dataType"></param>
		;;; <returns></returns>
		public method DeserializeObject, @object
			obj, @JsonObject
			out dataType, FieldDataType
			record
				dataTypeInt, @JsonInt
				propValue, @JsonValue
			endrecord
		proc
			dataTypeInt = ((@JsonInt)obj.GetProperty("DataType"))
			dataType = (FieldDataType)dataTypeInt.Value
			if(dataType == FieldDataType.DataObjectField) then
			begin
				mreturn DeserializeObject(obj, ^null)
			end
			else if(dataType == FieldDataType.DataObjectCollectionField) then
			begin
				mreturn DeserializeObjectCollection(obj)
			end
			else
			begin
				obj.TryGetProperty("PassedValue", propValue)
				if(dataType == FieldDataType.AlphaField) then
				begin
					if(propValue == ^null) then
						mreturn (@object)""
					else
					begin
						data textObject, @JsonText, ((@JsonText)propValue)
						mreturn textObject.Value
					end
				end
				else if(dataType == FieldDataType.DecimalField) then
				begin
					if(propValue == ^null) then
					begin
						mreturn (@object)"0"
					end
					else
					begin
						mreturn ((@JsonText)propValue).Value
					end
				end
				else if(dataType == FieldDataType.ImpliedDecimal) then
				begin
					if(propValue == ^null) then
					begin
						mreturn (@object)"0"
					end
					else
					begin
						mreturn ((@JsonText)propValue).Value
					end
				end
				else if(dataType == FieldDataType.IntegerField)
				begin
					data intValue, i4, 0
					if(propValue != ^null)
						intValue = ((@JsonInt)propValue).Value
				
					mreturn (@object)intValue
				end
			end

		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="ttChannel"></param>
		;;; <param name="frameHeader"></param>
		;;; <returns></returns>
		private method ReadCallBlock, boolean
			required in ttChannel, i
			required in frameHeader, i4
			required in leftovers, a
			required in leftoversLength, i
			record
				jsonReader, @Json
				parsedJson, @JsonValue
				serializer, @DispatchSerializer
				result, boolean
				readerPosition, int
				remainingRead, int
			endrecord
		proc
			jsonReader = new Json()
			serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
			;;reuse the same buffer if possible
			if(mReadBufferSize < frameHeader)
			begin
				if(mReadBuffer != 0) then
				begin
					MaybeLog(6, "Dispatcher: reallocating buffer was " + %string(mReadBufferSize) + " -> " + %string(frameHeader) )
					mReadBuffer = %mem_proc(DM_RESIZ, frameHeader, mReadBuffer)
					mReadBufferSize = frameHeader
				end
				else
				begin
					MaybeLog(6, "Dispatcher: allocating buffer with length" + %string(frameHeader))
					mReadBuffer = %mem_proc(DM_ALLOC | DM_STATIC, frameHeader)
					mReadBufferSize = frameHeader
				end
			end

			MaybeLog(6, "Dispatcher: Reading " + %string(frameHeader) + " total bytes of Content from input" )
			readerPosition = 1 + leftoversLength
			remainingRead = frameHeader - leftoversLength

			if(leftoversLength > 0)
			begin
				;;workaround for non conforming io on newlines
				decr(remainingRead)
				^m(MemStruct(1:leftoversLength), mReadBuffer) = leftovers(1:leftoversLength)
			end


			do 
			begin
				MaybeLog(6, "Dispatcher: Reading " + %string(remainingRead) + " bytes from input")
				gets(ttChannel, ^m(MemStruct(readerPosition:remainingRead), mReadBuffer), wait:100, MASK:mActivationMask) [$ERR_TIMOUT=again]
			again,	
				MaybeLog(6, "Dispatcher: Reading Content from input" + ^m(MemStruct(readerPosition:remainingRead), mReadBuffer) + ": got " + %string(%rdlen(ttChannel)) + " bytes, was expecting " + %string(remainingRead) + " bytes")
				readerPosition += %rdlen(ttChannel)
				remainingRead = frameHeader - readerPosition
				
			end
			until remainingRead <= 0

			MaybeLog(6, "Dispatcher: Parsing buffer " + ^m(MemStruct(1:frameHeader), mReadBuffer))
			parsedJson = jsonReader.ParseJson(^m(MemStruct(1:readerPosition - 1), mReadBuffer))

			if (!(parsedJson .is. @JsonObject) && !(parsedJson .is. @JsonArray))
			begin
				ReportError("failed to parse json request", -32700, -1, serializer)
				mreturn true
			end

			MaybeLog(5, "Dispatcher: Finished Json Parsing")

			result = true
			if(parsedJson .is. JsonObject) then
			begin
				MaybeLog(5, "Dispatcher: Single Call")
				result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
			end
			else if(parsedJson .is. JsonArray)
			begin
				data parsedArray, @JsonArray
				data jsonVal, @JsonValue
				parsedArray = (@JsonArray)parsedJson

				MaybeLog(5, "Dispatcher: Batch Call")

				serializer.ArrayOpen()
				foreach jsonVal in parsedArray.arrayValues
				begin
					if(jsonVal .is. JsonObject) then
					begin
						result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
						if(!result)
							exitloop
					end
					else
					begin
						ReportError("failed to parse json request", -32700, -1, serializer)
					end
				end
				serializer.ArrayClose()
			end

			flush(ttChannel)
			mreturn result

		endmethod

		public method ReportError, void
			errorText, @string
			errorCode, int
			messageId, int
			serializer, @DispatchSerializer
			record
				scopeLog, @string
		proc
			serializer.OutputScopeAbort()
			serializer.MapOpen()
			serializer.Pair("jsonrpc", "2.0")
			serializer.String("error")
			serializer.MapOpen()
			serializer.Pair("code", errorCode)
			serializer.Pair("message", errorText)

			;;if scope logging is active return everything that was logged as part of this request scope
			scopeLog = Logger.Instance.CurrentScopeLog()
			if(scopeLog != ^null && scopeLog.Length > 0)
				serializer.Pair("data", scopeLog)

			serializer.MapClose()

			if(messageId > -1) then
				serializer.Pair("id", messageId)
			else
				serializer.PairNull("id")

			serializer.MapClose()

			MaybeLog(1, "ReportError: " + errorText + " messageId" + %string(messageId))
		endmethod

		public method ReportResult, void
			requestId, int
			result, @string
			serializer, @DispatchSerializer
		proc
			serializer.MapOpen()
			serializer.Pair("jsonrpc", "2.0")
			serializer.Pair("result", result)
			
			if(requestId > -1) then
				serializer.Pair("id", requestId)
			else
				serializer.PairNull("id")

			serializer.MapClose()

			MaybeLog(5, "ReportResult: " + result + " messageId" + %string(requestId))
		endmethod

		public method ReportResult, void
			requestId, int
			result, n
			serializer, @DispatchSerializer
		proc
			serializer.MapOpen()
			serializer.Pair("jsonrpc", "2.0")
			serializer.Pair("result", result)
			
			if(requestId > -1) then
				serializer.Pair("id", requestId)
			else
				serializer.PairNull("id")

			serializer.MapClose()
			MaybeLog(5, "ReportResult: " + %string(result) + " messageId" + %string(requestId))
		endmethod

		public method ReportResult, void
			requestId, int
			result, [#]@object
			inputSet, [#]boolean
			serializer, @DispatchSerializer
			record
				arg, @object
				ii, int
		proc
			serializer.MapOpen()
			serializer.Pair("jsonrpc", "2.0")
			
			serializer.ArrayOpen()
			ii = 0
			foreach arg in result
			begin
				incr ii
				if(inputSet[ii])
				begin
					serializer.MapOpen()
					serializer.Pair("Position", ii)
					serializer.String("Value")
					SerializeObject(arg, serializer)
					serializer.MapClose()
				end
			end

			serializer.ArrayClose()
			
			if(requestId > -1) then
				serializer.Pair("id", requestId)
			else
				serializer.PairNull("id")

			serializer.MapClose()
			MaybeLog(5, "ReportResult: array(" + %string(result.Length) + ") messageId" + %string(requestId))
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="ttChannel"></param>
		public method Dispatch, void
			ttChannel, i
			record PacketLength
				contentLengthPart, a16
				lengthValue, a10
				padding, a2
			endrecord
			record ContentType
				contentTypeBuffer, a255
			endrecord
			record
				leftoverData, a1
				leftoverLength, int
			record
				running, boolean
				frameHeader, d10
				contentTypePos, int
			endrecord
		proc
			;;read 10 bytes of data from input when its available
			;;read count of bytes from input (in chunks ideally) 
			;;look for the target routine name
			;;build rcb block for the call
			;;deserialize arguments based on the types in json
			;;make the call
			;;trap any exceptions
			try
			begin
				running = true
				while(running)
				begin
					do 
					begin
						gets(ttChannel, PacketLength, wait:100)  [$ERR_TIMOUT=again]
					again,		
						MaybeLog(6, "Dispatcher: Reading ContentLength from input" + %atrim(PacketLength) + ":" + %string(%rdlen(ttChannel)))
					end
					until %rdlen(ttChannel) > 18

					frameHeader = ^d(%atrim(lengthValue))
					contentTypePos = 1
					while(contentTypePos < 255)
					begin
					againContent,	
						gets(ttChannel, ContentType(contentTypePos:1), wait:100, MASK:mActivationMask)  [$ERR_TIMOUT=againContent]
						if(contentTypePos > 3 && ContentType(contentTypePos:1) == %char(10))
						begin
							leftoverLength = 0
							exitloop
						end


						if(ContentType(contentTypePos:1) == '{')
						begin
							leftoverData = '{'
							leftoverLength = 1
							exitloop
						end

						contentTypePos += %rdlen(ttChannel)
					end

					MaybeLog(6, "Dispatcher: Reading ContentType from input" + %atrim(ContentType) + ":" + %string(contentTypePos))

					MaybeLog(5, "Dispatcher: starting callblock processing with ContentLength " + %atrim(lengthValue) + " ContentType " + %atrim(ContentType))

					running = ReadCallBlock(ttChannel, (int)frameHeader + 1, leftoverData, leftoverLength)
				end
				writes(ttChannel, "Shutting down due to running == false")
			end
			catch(ex, @Exception)
			begin
				data serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
				ReportError(ex.ToString(), -32603, -1, serializer)
			end
			endtry
		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="jsonData"></param>
		;;; <param name="responseChannel"></param>
		;;; <returns></returns>
		public method ProcessCallBlock, boolean
			jsonData, @JsonObject
			serializer, @DispatchSerializer
			record
				requestId, int
				name, @string
				argArrayList, @ArrayList
				dispatchStub, @RoutineStub
			endrecord
		proc
			
			if(!jsonData.TryGetProperty("id", requestId))
				requestId = -1

			if(!jsonData.TryGetProperty("method", name))
			begin
				ReportError("method name missing", -32600, requestId, serializer)
			end

			MaybeLog(5, "Dispatcher: method target was " + name)

			serializer.OutputScopeOpen()

			try
			begin
				if(name.StartsWith("rpc.")) then
				begin
					if(name == "rpc.shutdown") then
					begin
						;;we've been asked to shutdown so return false and let the outer loop take care of it
						ReportResult(requestId, 0, serializer)
						serializer.OutputScopeClose()
						mreturn false
					end
					else if(name == "rpc.ping") then
					begin
						ReportResult(requestId, 0, serializer)
					end
					else if(name == "rpc.serializer_protocol") then
					begin
						ReportResult(requestId, "1.0", serializer)
					end
					else if(name == "rpc.set_log_level") then
					begin
						data logArg, @JsonInt
						argArrayList = ((@JsonArray)jsonData.GetProperty("params")).arrayValues

						if(argArrayList.Count != 1 || !(argArrayList[0] .is. JsonInt)) then
							ReportError("invalid parameters for rpc.set_log_level", -32602, requestId, serializer)
						else
						begin
							Logger.LogLevel = ((JsonInt)argArrayList[0]).Value
							ReportResult(requestId, 0, serializer)
						end

					end
					else if(name == "rpc.chain") then
					begin
						;;TODO: flush everything out and stop chain to ourselves
						ReportError("rpc.chain not yet implemented", -32603, requestId, serializer)
					end
					else
					begin
						;;extension method was called but isnt supported
						ReportError("unknown extension method", -32601, requestId, serializer)
					end
				end
				else
				begin
					if(mDispatchStubs.TryGet(name, dispatchStub)) then
					begin
						MaybeLog(5, "Dispatcher: dispatching compiled stub for " + name)
						dispatchStub.Dispatch(name, jsonData, serializer, this)
						MaybeLog(5, "Dispatcher: finished dispatching compiled stub for " + name)
					end
					else
					begin
						data argValue, @JsonValue
						data arg, @JsonObject
						data argValueArray, [#]@Object
						data rcbid, i4
						data ii, i4, 0
						data responseSet, [#]boolean
						argArrayList = new ArrayList()
						MaybeLog(5, "Dispatcher: dispatching dynamically for " + name)
						if(jsonData.HasProperty("params"))
						begin
							data arg, @JsonObject
							data ii = 0
							argArrayList = ((@JsonArray)jsonData.GetProperty("params")).arrayValues
						end
						argValueArray = new object[argArrayList.Count]
						responseSet = new boolean[argArrayList.Count]
						rcbid = %rcb_create(argArrayList.Count) 
						xcall rcb_setfnc(rcbid, name)
						foreach argValue in argArrayList as @JsonValue
						begin
							data argType, FieldDataType
							data argLength, i4, 0
							data argPrecision, i4, 0
							incr ii

							if(argValue .is. @JsonObject) then
								arg = (@JsonObject)argValue
							else
								throw new Exception("Invalid protocol, input parameter type was not a JSON object")

							;;the arguments need somewhere to live while we're building up the call so put them into this array
							argValueArray[ii] = DeserializeObject(arg, argType)
							if(!jsonData.TryGetBoolProperty("ReturnedValue", responseSet[ii]))
								responseSet[ii] = false
							
							if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
							begin
								data elementSizeValue, @JsonValue
								if(jsonData.HasProperty("DecimalPrecision"))
									argPrecision = ((@JsonInt)jsonData.GetProperty("DecimalPrecision")).Value

								if(jsonData.TryGetProperty("ElementSize", elementSizeValue)) then
									argLength = ((@JsonInt)elementSizeValue).Value
								else
									argLength = ^size((n)argValueArray[ii])

								xcall rcb_setarg(rcbid, (n)argValueArray[ii], ii, (i)argType, argLength, argPrecision)
							end
							else
								xcall rcb_setarg(rcbid, argValueArray[ii], ii)
						end
						xcall rcb_call(rcbid) 
						ReportResult(requestId, argValueArray, responseSet, serializer)
						MaybeLog(5, "Dispatcher: finished dispatching dynamically for " + name)
					end
				end
				serializer.OutputScopeClose()
			end
			catch(rtnNotFound, @RoutineNotFound)
			begin
				serializer.OutputScopeAbort()
				ReportError(rtnNotFound.ToString(), -32601, requestId, serializer)
			end
			catch(ex, @Exception)
			begin
				serializer.OutputScopeAbort()
				;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
				ReportError(ex.ToString(), -32000, requestId, serializer)
			end
			endtry

			mreturn true
		endmethod

	endclass

	;;; <summary>
	;;; 
	;;; </summary>
	abstract class RoutineStub
		
		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name="name"></param>
		;;; <param name="callFrame"></param>
		;;; <param name="serializer"></param>
		;;; <param name="dispatcher"></param>
		protected abstract method DispatchInternal, void
			name, @string
			callFrame, @JsonObject
			serializer, @DispatchSerializer
			dispatcher, @RoutineDispatcher
		proc

		endmethod

		public method Dispatch, void
			name, @string
			callFrame, @JsonObject
			serializer, @DispatchSerializer
			dispatcher, @RoutineDispatcher
			record
				requestId, int
		proc
			serializer.MapOpen()
			serializer.Pair("jsonrpc", "2.0")

			if(callFrame.TryGetProperty("id", requestId)) then
				serializer.Pair("id", requestId)
			else
				serializer.PairNull("id")

			serializer.String("result")
			serializer.ArrayOpen()

			DispatchInternal(name, callFrame, serializer, dispatcher)

			;;Terminate the "ReturnParameters" array
			serializer.ArrayClose()

			;;Terminate the "Result" object
			serializer.MapClose()
			;;Terminate the response object
			serializer.MapClose()
		endmethod
	endclass

endnamespace