import System
import System.Collections

namespace Harmony.Core

	public abstract class DataObjectMetadataBase
		
		static method DataObjectMetadataBase
		proc
			mLookupRCBId = %rcb_create(1, DM_STATIC)
		endmethod

		
		private static mLookupRCBId, i4
		public static method LookupType, @DataObjectMetadataBase
			targetType, @string
			record
				result, @DataObjectMetadataBase
		proc
			;;it might be possible to use the symbol api as a dictionary here so we dont have to make an rcb call each time we want to look this up
			xcall rcb_setarg(mLookupRCBId, result, 1) 
			xcall rcb_setfnc(mLookupRCBId, "Meta" + targetType)  ;this doesnt deal with namespaces, users must not allow dataobjects that differ only by namespace
			xcall rcb_call(mLookupRCBId)  
			xcall rcb_setarg(mLookupRCBId, ^null, 1) ;;dont leave around a reference to the last DataObjectMetadataBase handle, that might corrupt memory
			mreturn result
		endmethod

		public RPSStructureName	,String
		public RPSStructureSize	,i4

		;;backing field to store the objects field names
		protected mFieldNames	,@ArrayList
		
		public abstract method GetFieldByName, @FieldDataDefinition
				in required fldName,	string
		proc
		endmethod
		
		;;; <summary>
		;;;  Readonly property that returns the names of the fields defined within the $$Symphony Data Object$$.
		;;; </summary>
		public property FieldNames, @ArrayList
			method get
			proc
				mreturn mFieldNames
			endmethod
		endproperty

		protected method MakeFieldInfo, @FieldDataDefinition
			languageName, String
			dataType, string
			elementSize, int
			structurePosition, int
			decimalPrecision ,int
			clearField, boolean
			endparams
			record
				fieldInfo, @FieldDataDefinition
		proc
			fieldInfo = new FieldDataDefinition() { LanguageName = languageName, ElementSize = elementSize, StructurePosition = structurePosition, DecimalPrecision = decimalPrecision, ClearField = clearField }
			

			using dataType select
			("ALPHA"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("BINARY"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("DATE"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("DECIMAL"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("IMPLIED"),
			begin
				fieldInfo.DataType = FieldDataType.ImpliedDecimal
			end
			("INTEGER"),
			begin
				fieldInfo.DataType = FieldDataType.IntegerField
			end
			("JULIAN"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("TIME"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("USER ALPHA"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("USER DATE"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("USER NUMERIC"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			endusing
			mreturn fieldInfo
		endmethod
		
		;;; <summary>
		;;; Expose the underlying structure size.
		;;; </summary>
		public virtual property StructureSize, int
			method get
			proc
				mreturn RPSStructureSize
			endmethod
		endproperty

		;;generated metadata type can just call new and create the data object base
		public abstract method MakeNew, @DataObjectBase
			dataArea, a
			grfa, a
		proc
		endmethod
	endclass

endnamespace
