
import System
import System.Collections.Generic
import System.Text
import System.Collections.Concurrent
import System.Runtime.CompilerServices

namespace Harmony.Core

	public abstract class DataObjectMetadataBase

		public static MetadataLookup, @ConcurrentDictionary<Type, DataObjectMetadataBase>, new ConcurrentDictionary<Type, DataObjectMetadataBase>()

		public static method LookupType, @DataObjectMetadataBase
			targetType, @Type
		proc
			data result, @DataObjectMetadataBase
			if(!MetadataLookup.TryGetValue(targetType, result))
			begin
				;;the metadata type wasnt registered
				;;ensure the static constructor for the DataObject has been run
				RuntimeHelpers.RunClassConstructor(targetType.TypeHandle)
				if(!MetadataLookup.TryGetValue(targetType, result))
					throw new NotImplementedException("static constructor for data object type didnt register metadatatype")
			end
			mreturn result
		endmethod

		public RPSStructureName	,String
		public RPSStructureSize	,Int32

		;;backing field to store the objects field names
		protected mFieldNames	,@List<String>, new List<String>()
		protected mFields, @List<FieldDataDefinition>, new List<FieldDataDefinition>()
		
		public method GetFieldByName, @FieldDataDefinition
				in required fldName,	string
		proc
			mreturn mFields[mfieldDictionary[fldName]]
		endmethod
		
		public abstract method FormatKeyLiteral, a
			keyNumber, int
			parts, @Dictionary<string, Object>
		proc
		endmethod


		;;this returns null if there is no key, fully satsified by the supplied set of key names
		public method GetKeyNumberByFieldNames, int?
			in required fldNames, [#]string
		proc
			mreturn ^null
		endmethod


		;;; <summary>
		;;;  Readonly property that returns the names of the fields defined within the $$Symphony Data Object$$.
		;;; </summary>
		public property FieldNames, @List<String>
			method get
			proc
				mreturn mFieldNames
			endmethod
		endproperty
		
		;;backing field to store the objects field headings for report/excel export, etc
		protected mFieldHeadings	,@List<String>, new List<String>()
		
		;;; <summary>
		;;;  Readonly property that returns the report headings of the fields defined within the $$Symphony Data Object$$.
		;;; </summary>
		public property FieldHeadings, @List<String>
			method get
			proc
				mreturn mFieldHeadings
			endmethod
		endproperty
		
		;;this logic allows a generated data oject to store off a copy of the field details
		;;and prevent itself from re-creating them
		
		protected mfieldDictionary	,@Dictionary<string, int>, new Dictionary<string, int>()
		protected mFieldsInKeys, @Dictionary<string, List<int>>
		protected mKeyDictionary, @Dictionary<int, List<string>>
		;;this can be called multiple times with the same key number to create a composite key
		protected method AddKeyInfo, void
			keyNumber, int
			fieldName, @string
		proc
			data memberOfKeys, @List<int>
			if(!mFieldsInKeys.TryGetValue(fieldName, memberOfKeys))
			begin
				memberOfKeys = new List<int>()
				mFieldsInKeys.Add(fieldName, memberOfKeys)
			end
			memberOfKeys.Add(keyNumber)

			data keyParts, @List<string>
			if(!mKeyDictionary.TryGetValue(keyNumber, keyParts))
			begin
				keyParts = new List<string>()
				mKeyDictionary.Add(keyNumber, keyParts)
			end
			keyParts.Add(fieldName)
		endmethod


		protected method AddFieldInfo, void
			languageName, String
			dataType, string
			elementSize, int
			structurePosition, int
			decimalPrecision ,int
			clearField, boolean
			default tagValue, @string, ^null
			endparams
		proc
			data fieldInfo = new FieldDataDefinition() { LanguageName = languageName, ElementSize = elementSize, StructurePosition = structurePosition, DecimalPrecision = decimalPrecision, ClearField = clearField, TagValue = tagValue }

			using dataType select
			("ALPHA"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("BINARY"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("DATE"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("DECIMAL"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("IMPLIED"),
			begin
				fieldInfo.DataType = FieldDataType.ImpliedDecimal
			end
			("INTEGER"),
			begin
				fieldInfo.DataType = FieldDataType.IntegerField
			end
			("JULIAN"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("TIME"),
			begin
				fieldInfo.DataType = FieldDataType.DecimalField
			end
			("USER ALPHA"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("USER DATE"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("USER NUMERIC"),
			begin
				fieldInfo.DataType = FieldDataType.AlphaField
			end
			("TAG_LITERAL"),
			begin
				fieldInfo.DataType = FieldDataType.TagLiteral
			end
			endusing

			mFields.Add(fieldInfo)
			mfieldDictionary.Add(languageName, mFields.Count - 1)
		endmethod

		;;; <summary>
		;;;  Return the field index based on the passed field name.
		;;; </summary>
		;;; <param name="fldName">Name of the field.</param>
		public method GetFieldFromStringIndex, int
			in required fldName			,String
			endparams
		proc
			mreturn mfieldDictionary[fldName]
		endmethod
		
		;;; <summary>
		;;; Expose the underlying structure size.
		;;; </summary>
		public virtual property StructureSize, Int32
			method get
			proc
				mreturn RPSStructureSize
			endmethod
		endproperty

		;;generated metadata type can just call new and create the data object base
		public abstract method MakeNew, @DataObjectBase
			dataArea, a
			grfa, a
		proc
		endmethod

		;;generated metadata type can just call new and create the data object base
		public abstract method MakeNew, @DataObjectBase
			dataArea, a
			grfa, a
			joinedObjects, [#]KeyValuePair<string, object>
		proc
		endmethod

		public SynergyMemberInfo, @List<System.Reflection.MemberInfo>

	endclass

endnamespace
