import System
import System.Collections.Generic
import System.Text
import Harmony.Core.Enumerations
import Synergex.SynergyDE.Select
import System.Linq.Expressions
import Harmony.Core.Utility
import Remotion.Linq.Clauses
import System.Linq

namespace Harmony.Core.FileIO.Queryable

	
	internal class WhereExpressionBuilder extends ExpressionVisitor
		;;this might need to be a stack to handle nesting fully
		private mWhereStack, @Stack<Synergex.SynergyDE.Select.Where>
		private mOnStack, @Stack<Synergex.SynergyDE.Select.On>
		private mRecordAreas, @Dictionary<IQuerySource, int>
		private mDataObjects, @Dictionary<IQuerySource, DataObjectMetadataBase>
		private mCaseSensitive, boolean
		private mParameters, @IReadOnlyDictionary<string, Object>
		private mAddAdditionalSource, @Action<IQuerySource, Expression, Expression> 
		public method WhereExpressionBuilder
			recordArea, int
			dataObject, @DataObjectMetadataBase
			fromSource, @IQuerySource
			caseSensitive, boolean
			parameters, @IReadOnlyDictionary<string, Object>
			addAdditionalSource, @Action<IQuerySource, Expression, Expression> 
		proc
			mWhereStack = new Stack<Synergex.SynergyDE.Select.Where>()
			mRecordAreas = new Dictionary<IQuerySource, int>() { { fromSource, recordArea } }
			mDataObjects = new Dictionary<IQuerySource, DataObjectMetadataBase>() { { fromSource, dataObject } }
			mParameters = parameters
			mWhereStack = new Stack<Synergex.SynergyDE.Select.Where>()
			mOnStack = new Stack<Synergex.SynergyDE.Select.On>()
			mAddAdditionalSource = addAdditionalSource
		endmethod

		public method AddFromClause, void
			fromSource, @IQuerySource
			recordArea, int
			dataObject, @DataObjectMetadataBase
		proc
			mDataObjects.Add(fromSource, dataObject)
			mRecordAreas.Add(fromSource, recordArea)
		endmethod

;		public property WhereExpression, @Synergex.SynergyDE.Select.Where
;			method get
;			proc
;				if(!mVisited == ^null)
;				begin
;					Visit(mExpression)
;				end
;
;				mreturn mWhereStack.Count > 0 ? mWhereStack.Peek() : ^null
;			endmethod
;		endproperty
;
;		public property OnExpressions, @Dictionary<string, Synergex.SynergyDE.Select.On>
;			method get
;			proc
;				if(mWhereStack == ^null)
;				begin
;					mWhereStack = new Stack<Synergex.SynergyDE.Select.Where>()
;					Visit(mExpression)
;				end
;
;				mreturn mWhereStack.Count > 0 ? mWhereStack.Peek() : ^null
;			endmethod
;		endproperty

		public method VisitForWhere, @Where
			expr, @Expression
		proc
			mWhereStack = new Stack<Synergex.SynergyDE.Select.Where>()
			mOnStack = new Stack<Synergex.SynergyDE.Select.On>()
			Visit(expr)
			mreturn mWhereStack.Count > 0 ? mWhereStack.Peek() : ^null
		endmethod

		public method VisitForOn, @On
			expr, @Expression
		proc
			mWhereStack = new Stack<Synergex.SynergyDE.Select.Where>()
			mOnStack = new Stack<Synergex.SynergyDE.Select.On>()
			Visit(expr)
			mreturn mOnStack.Count > 0 ? mOnStack.Peek() : ^null
		endmethod

		public method VisitForOrderBy, @OrderBy
			expr, @Expression
		proc
			Visit(expr)
			mreturn ^null
		endmethod

		private method fieldOnClause  ,@On
			in req dataBuffer1			,a
			in req dataBuffer2			,a
			in req fieldDetails1		,@FieldDataDefinition
			in req fieldDetails2		,@FieldDataDefinition
			in req theOperator			,whereClauseOperator
		proc

			if(fieldDetails1.DataType != fieldDetails2.DataType)
				throw new NotImplementedException("field to field comparisons must be of the same type")

			using theOperator select
			(whereClauseOperator.EqualTo),
			begin
				using fieldDetails1.DataType select
				(FieldDataType.AlphaField),
				begin
					if(mCaseSensitive) then
						mreturn (On)(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize) .eqs. dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize))
					else
						throw new NotImplementedException()
				end
				(FieldDataType.IntegerField),
				begin
					mreturn (On)(^i(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize)) .eqs. ^i(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize)))
				end
				(FieldDataType.DecimalField),
				begin
					mreturn (On)(^d(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize)) .eqs. ^d(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize)))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					mreturn (On)(^d(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize), fieldDetails1.DecimalPrecision) .eqs. ^d(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize), fieldDetails2.DecimalPrecision))
				end
				endusing

			end
			(whereClauseOperator.NotEqualTo),
			begin
			end
			(whereClauseOperator.GreaterThan),
			begin
			end
			(whereClauseOperator.GreaterThanOrEqualTo),
			begin
			end
			(whereClauseOperator.LessThan),
			begin
			end
			(whereClauseOperator.LessThanOrEqualTo),
			begin
			end
			(whereClauseOperator.IsLike),
			begin
			end
			(whereClauseOperator.IsBetween),
			begin
			end
			(WhereClauseOperator.IsIn),
			begin
			end
			endusing
			throw new NotImplementedException()
		endmethod

		private method fieldWhereClause  ,@Where
			in req dataBuffer1			,a
			in req dataBuffer2			,a
			in req fieldDetails1		,@FieldDataDefinition
			in req fieldDetails2		,@FieldDataDefinition
			in req theOperator			,whereClauseOperator
		proc

			if(fieldDetails1.DataType != fieldDetails2.DataType)
				throw new NotImplementedException("field to field comparisons must be of the same type")

			using theOperator select
			(whereClauseOperator.EqualTo),
			begin
				using fieldDetails1.DataType select
				(FieldDataType.AlphaField),
				begin
					if(mCaseSensitive) then
						mreturn (Where)(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize) .eqs. dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize))
					else
						mreturn (NoCaseWhere)(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize) .eqs. dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize))
				end
				(FieldDataType.IntegerField),
				begin
					mreturn (Where)(^i(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize)) .eqs. ^i(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize)))
				end
				(FieldDataType.DecimalField),
				begin
					mreturn (Where)(^d(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize)) .eqs. ^d(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize)))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					mreturn (Where)(^d(dataBuffer1(fieldDetails1.StructurePosition:fieldDetails1.ElementSize), fieldDetails1.DecimalPrecision) .eqs. ^d(dataBuffer2(fieldDetails2.StructurePosition:fieldDetails2.ElementSize), fieldDetails2.DecimalPrecision))
				end
				endusing

			end
			(whereClauseOperator.NotEqualTo),
			begin
			end
			(whereClauseOperator.GreaterThan),
			begin
			end
			(whereClauseOperator.GreaterThanOrEqualTo),
			begin
			end
			(whereClauseOperator.LessThan),
			begin
			end
			(whereClauseOperator.LessThanOrEqualTo),
			begin
			end
			(whereClauseOperator.IsLike),
			begin
			end
			(whereClauseOperator.IsBetween),
			begin
			end
			(WhereClauseOperator.IsIn),
			begin
			end
			endusing
			throw new NotImplementedException()
		endmethod

		;;add the actual field and value to the where clause
		private method fieldWhereClause	,@Where
			in req dataBuffer			,a
			in req fieldDetails			,@FieldDataDefinition
			in req theOperator			,whereClauseOperator
			in req theValue				,a
			in req theValue2			,a
			endparams
			
			structure tmpStructure
				fld	,a1
			endstructure
			
			record
				stPos	,i4
				edPos	,i4
				bNum	,d3
				memPnt	,i4
			endrecord
		proc
			memPnt = %mem_proc(DM_ALLOC, fieldDetails.ElementSize)
			^m(tmpStructure(1:fieldDetails.ElementSize), memPnt) = theValue
			
			using theOperator select
			(whereClauseOperator.EqualTo),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					;;if we have a "%" as the last character let's do a "starts with" type operation
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize

					if (length > 1 && %atrim(^m(tmpStructure(length:1), memPnt)) == "%") then
					begin
						decr length
						if (mCaseSensitive == true) then
						begin
							DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: StartsWith Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, length, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
							mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:length) .eqs. (^m(tmpStructure(1:length), memPnt)))
						end
						else
						begin
							DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: StartsWith NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, length, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
							mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:length) .eqs. (^m(tmpStructure(1:length), memPnt)))
						end
					end
					else
					begin
						if (mCaseSensitive == true) then
						begin
							DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: EqualTo Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
							mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .eqs. (^m(tmpStructure(1:length), memPnt)))
						end
						else
						begin
							DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: EqualTo NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
							mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .eqs. (^m(tmpStructure(1:length), memPnt)))
						end
					end
				end
				(FieldDataType.IntegerField),
				begin
					data intValue	,string	,^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)
					;;we may be a boolean type!!
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "TRUE") intValue = 1
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "FALS") intValue = 0

					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: EqualTo Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .eq. %integer(intValue, fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: EqualTo Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .eq. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: EqualTo Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .eq. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.NotEqualTo),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize
					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: NotEqualTo Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .nes. (^m(tmpStructure(1:length), memPnt)))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: NotEqualTo NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .nes. (^m(tmpStructure(1:length), memPnt)))
					end
				end
				(FieldDataType.IntegerField),
				begin
					data intValue	,string	,^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)
					;;we may be a boolean type!!
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "TRUE") intValue = 1
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "FALS") intValue = 0

					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: NotEqualTo Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .ne. %integer(intValue, fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: NotEqualTo Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .ne. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: NotEqualTo Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .ne. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.GreaterThan),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize

					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThan Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .gts. (^m(tmpStructure(1:length), memPnt)))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThan NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .gts. (^m(tmpStructure(1:length), memPnt)))
					end
				end
				(FieldDataType.IntegerField),
				begin
					data intValue	,string	,^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)
					;;we may be a boolean type!!
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "TRUE") intValue = 1
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "FALS") intValue = 0

					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThan Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .gt. %integer(intValue, fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThan Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .gt. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThan Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .gt. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.GreaterThanOrEqualTo),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize

					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThanOrEqualTo Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .ges. (^m(tmpStructure(1:length), memPnt)))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThanOrEqualTo NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .ges. (^m(tmpStructure(1:length), memPnt)))
					end
				end
				(FieldDataType.IntegerField),
				begin
					data intValue	,string	,^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)
					;;we may be a boolean type!!
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "TRUE") intValue = 1
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "FALS") intValue = 0

					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThanOrEqualTo Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .ge. %integer(intValue, fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThanOrEqualTo Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .ge. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: GreaterThanOrEqualTo Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .ge. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.LessThan),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize
					
					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThan Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .lts. (^m(tmpStructure(1:length), memPnt)))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThan NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .lts. (^m(tmpStructure(1:length), memPnt)))
					end
				end
				(FieldDataType.IntegerField),
				begin
					data intValue	,string	,^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)
					;;we may be a boolean type!!
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "TRUE") intValue = 1
					if (fieldDetails.ElementSize == 4 && intValue.ToUpper() == "FALS") intValue = 0

					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThan Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .lt. %integer(intValue, fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThan Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .lt. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThan Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .lt. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.LessThanOrEqualTo),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize

					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThanOrEqualTo Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (Where)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .les. (^m(tmpStructure(1:length), memPnt)))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThanOrEqualTo NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn (NoCaseWhere)(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize) .les. ^m(tmpStructure(1:length), memPnt))
					end
				end
				(FieldDataType.IntegerField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThanOrEqualTo Where (IntegerField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleIntegerDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .le. %integer(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt), fieldDetails.ElementSize))
				end
				(FieldDataType.ImpliedDecimal),
				begin
					DebugLogSession.Logging.LogDiagnostic("LessThanOrEqualTo Where (ImpliedDecimal) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision) .le. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				(FieldDataType.DecimalField),
				begin
					DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: LessThanOrEqualTo Where (DecimalField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize,new MemoryHandleImpliedDebugLogHelper(memPnt, fieldDetails.ElementSize))
					mreturn (Where)(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)) .le. %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)))
				end
				endusing
			end
			(whereClauseOperator.IsLike),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize

					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsLike Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn Where.Contains(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), ((^m(tmpStructure(1:length), memPnt) - "%") - "%"))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsLike NoCaseWhere (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn NoCaseWhere.Contains(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), (^m(tmpStructure(1:length), memPnt) - "%") - "%")
					end
				end
				endusing
			end
			(whereClauseOperator.IsBetween),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize
					
					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsBetween Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2} and {3}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize), %atrim(theValue2))
						mreturn Where.Between(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), (^m(tmpStructure(1:length), memPnt)), %atrim(theValue2))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsBetween Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2} and {3}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize), %atrim(theValue2))
						mreturn NoCaseWhere.Between(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), (^m(tmpStructure(1:length), memPnt)), %atrim(theValue2))
					end
				end
				(FieldDataType.IntegerField),
					mreturn Where.Between(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)), %integer(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt), fieldDetails.ElementSize), %integer(theValue2, fieldDetails.ElementSize))
				(FieldDataType.ImpliedDecimal),
					mreturn Where.Between(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision), %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)), %implied(theValue2))
				(FieldDataType.DecimalField),
					mreturn Where.Between(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)), %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)), %implied(theValue2))
				endusing
			end
			(whereClauseOperator.IsIn),
			begin
				using fieldDetails.DataType select
				(FieldDataType.AlphaField),
				begin
					data length	,i4	,%trim(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt))
					if (!length) length = fieldDetails.ElementSize
					
					if (mCaseSensitive == true) then
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsIn Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn Where.In(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), (^m(tmpStructure(1:length), memPnt)), %atrim(theValue2))
					end
					else
					begin
						DebugLogSession.Logging.LogDiagnostic("HARMONY-commandParser::fieldWhereClause: IsIn Where (AlphaField) clause.  Structure position : {0}, size : {1}, value : {2}", fieldDetails.StructurePosition, fieldDetails.ElementSize, new MemoryHandleDebugLogHelper(memPnt, fieldDetails.ElementSize))
						mreturn NoCaseWhere.Between(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), (^m(tmpStructure(1:length), memPnt)), %atrim(theValue2))
					end
				end
				(FieldDataType.IntegerField),
					mreturn Where.Between(^i(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)), %integer(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt), fieldDetails.ElementSize), %integer(theValue2, fieldDetails.ElementSize))
				(FieldDataType.ImpliedDecimal),
					mreturn Where.Between(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize), fieldDetails.DecimalPrecision), %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)), %implied(theValue2))
				(FieldDataType.DecimalField),
					mreturn Where.Between(^d(dataBuffer(fieldDetails.StructurePosition:fieldDetails.ElementSize)), %implied(^m(tmpStructure(1:fieldDetails.ElementSize), memPnt)), %implied(theValue2))
				endusing
			end
			endusing
		endmethod	

		private static method OpKindFromExpression, void
			required in node, @Expression
			required inout op, WhereClauseOperator?
			required inout glue, WhereClauseConnector?
		proc
			op = ^null
			glue = ^null
			if(node.NodeType == ExpressionType.AndAlso || node.NodeType == ExpressionType.And) then
			begin
				glue = WhereClauseConnector.AndOperator
			end
			else if(node.NodeType == ExpressionType.OrElse)  then
			begin
				glue = WhereClauseConnector.OrOperator
			end
			else if(node.NodeType == ExpressionType.Equal) then
			begin
				op = WhereClauseOperator.EqualTo
			end
			else if(node.NodeType == ExpressionType.LessThan) then
			begin
				op = WhereClauseOperator.LessThan
			end
			else if(node.NodeType == ExpressionType.LessThanOrEqual) then
			begin
				op = WhereClauseOperator.LessThanOrEqualTo
			end
			else if(node.NodeType == ExpressionType.GreaterThan) then
			begin
				op = WhereClauseOperator.GreaterThan
			end
			else if(node.NodeType == ExpressionType.GreaterThanOrEqual) then
			begin
				op = WhereClauseOperator.GreaterThanOrEqualTo
			end
			else if(node.NodeType == ExpressionType.NotEqual) then
			begin
				op = WhereClauseOperator.NotEqualTo
			end
			else
				throw new NotImplementedException()
		endmethod

		private method FindTargetField, @Tuple<FieldDataDefinition, IQuerySource>
			node, @Expression
			node2, @Expression
			inout skipClause, boolean
		proc
			if(skipClause)
				mreturn ^null

			if(node .is. MemberExpression) then
			begin
				;;TODO this assumes we're only dealing with our target data object
				data dObj = mDataObjects.First()
				mreturn Tuple.Create(dObj.Value.GetFieldByName(((@MemberExpression)node).Member.Name), dObj.Key)
			end
			else if(node .is. MethodCallExpression) then
			begin
				data callNode = (@MethodCallExpression)node
				if(callNode.Method.Name == "Property")
				begin
					;;this is where we can do a metadata object lookup for join
					data memberTargetParameter = (@Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression)callNode.Arguments[0]
					data memberNameConstant = (@ConstantExpression)callNode.Arguments[1]
					data memberTargetType, @DataObjectMetadataBase, ^null
					if(!mDataObjects.TryGetValue(memberTargetParameter.ReferencedQuerySource, memberTargetType))
					begin
						skipClause = true
						mAddAdditionalSource(memberTargetParameter.ReferencedQuerySource, callNode, node2)
						mreturn ^null
					end
					
					;;if we're looking at a tag literal (fake) field just drop out here
					data targetField = memberTargetType.GetFieldByName(memberNameConstant.Value.ToString())
					if(((int)targetField.DataType & (int)FieldDataType.TagLiteral) != 0)
					begin
						mreturn ^null
					end
						
					mreturn Tuple.Create(targetField, memberTargetParameter.ReferencedQuerySource)
				end
			end
			else if(node .is. UnaryExpression && node.NodeType == ExpressionType.Convert)
			begin
				data convertNode = (@UnaryExpression)node
				mreturn FindTargetField(convertNode.Operand, node2, skipClause)
			end

			mreturn ^null
		endmethod

		private method FindConstantValue, a
			node, @Expression
		proc
			if(node .is. ConstantExpression) then
			begin
				data constNode = (@ConstantExpression)node
				mreturn constNode.Value.ToString()
			end
			else if(node .is. ParameterExpression && mParameters != ^null) then
			begin
				data paramNode = (@ParameterExpression)node
				data paramValue, @object
				if(mParameters.TryGetValue(paramNode.Name, paramValue))
					mreturn paramValue.ToString()
			end
			else if(node .is. MethodCallExpression) then
			begin
				data callNode = (@MethodCallExpression)node
				if(callNode.Method.Name == "Property")
				begin
					;;this is where we can do a metadata object lookup for join
					data memberTargetParameter = (@Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression)callNode.Arguments[0]
					data memberNameConstant, @ConstantExpression, (@ConstantExpression)callNode.Arguments[1]
					data memberTargetType, @DataObjectMetadataBase, mDataObjects[memberTargetParameter.ReferencedQuerySource]
					data targetField = memberTargetType.GetFieldByName(memberNameConstant.Value.ToString())
					if(((int)targetField.DataType & (int)FieldDataType.TagLiteral) != 0)
					begin
						mreturn targetField.TagValue
					end
				end
			end
			else if(node .is. UnaryExpression && node.NodeType == ExpressionType.Convert)
			begin
				data convertNode = (@UnaryExpression)node
				mreturn FindConstantValue(convertNode.Operand)
			end
			throw new NotImplementedException()
		endmethod

		protected override method VisitExtension, @Expression
			node, @System.Linq.Expressions.Expression 
			endparams
		proc
			if(node.GetType().Name == "NullSafeEqualExpression")
			begin
				data equalExpr = node.GetType().GetProperty("EqualExpression").GetValue(node)
				Visit((@BinaryExpression)equalExpr)
			end
			mreturn node
		endmethod

		private method ProcessWhereClause, void
			left, @Expression
			right, @Expression
			op, WhereClauseOperator
			structure tmpStructure
				fld,a1
			endstructure
		proc
			data skipClause, boolean, false
			;;TODO this doesnt deal with 'between'
			data leftTarget = FindTargetField(left, right, skipClause)
			data rightTarget = FindTargetField(right, left, skipClause)
			if(skipClause)
				mreturn

			if(leftTarget != ^null && rightTarget != ^null) then
			begin
				data dataObject1 = mDataObjects[leftTarget.Item2]
				data dataObject2 = mDataObjects[rightTarget.Item2]
				data recordArea1 = mRecordAreas[leftTarget.Item2]
				data recordArea2 = mRecordAreas[rightTarget.Item2]
				if(dataObject1 == dataObject2) then
				begin
					mWhereStack.Push(fieldWhereClause(^m(tmpStructure(1:dataObject1.StructureSize), recordArea1), 
					&	^m(tmpStructure(1:dataObject2.StructureSize), recordArea2), 
					&	leftTarget.Item1, 
					&	rightTarget.Item1,
					&	op))
				end
				else
				begin
					mOnStack.Push(fieldOnClause(^m(tmpStructure(1:dataObject1.StructureSize), recordArea1), 
					&	^m(tmpStructure(1:dataObject2.StructureSize), recordArea2), 
					&	leftTarget.Item1, 
					&	rightTarget.Item1,
					&	op))
				end
			end
			else if(leftTarget != ^null) then
			begin
				data dataObject1 = mDataObjects[leftTarget.Item2]
				data recordArea1 = mRecordAreas[leftTarget.Item2]
				mWhereStack.Push(fieldWhereClause(^m(tmpStructure(1:dataObject1.StructureSize), recordArea1), 
				&	leftTarget.Item1, 
				&	op,
				&	FindConstantValue(right), ""))
			end
			else if(rightTarget != ^null) then
			begin
				data dataObject1 = mDataObjects[rightTarget.Item2]
				data recordArea1 = mRecordAreas[rightTarget.Item2]
				mWhereStack.Push(fieldWhereClause(^m(tmpStructure(1:dataObject1.StructureSize), recordArea1), 
				&	rightTarget.Item1, 
				&	op,
				&	FindConstantValue(left), ""))
			end
			else
				throw new NotImplementedException("where expression must contain at least one field or property expression")
		endmethod


		protected override method VisitBinary, @Expression
			node, @BinaryExpression
		proc
			data op, WhereClauseOperator?, ^null
			data glue, WhereClauseConnector?, ^null
			OpKindFromExpression(node, op, glue)
			if(op != ^null) then
			begin
				;;this should be a composite key match them up by order
				if(node.Left .is. NewExpression && node.Right .is. NewExpression) then
				begin
					data newLeft = (@NewExpression)node.Left
					data newRight = (@NewExpression)node.Right
					data leftArgument = (@NewArrayExpression)newLeft.Arguments.First()
					data rightArgument = (@NewArrayExpression)newRight.Arguments.First()
					data i, int, 0
					for i from 0 thru leftArgument.Expressions.Count - 1 by 1
					begin
						ProcessWhereClause(leftArgument.Expressions[i], rightArgument.Expressions[i], op.Value)
					end

					
				end
				else
					ProcessWhereClause(node.Left, node.Right, op.Value)
			end
			else
			begin
				if(mOnStack.Count > 0) then
				begin
					Visit(node.Left)
					data leftOn = mOnStack.Pop()
					Visit(node.Right)
					if(mOnStack.Count > 0) then
					begin
						data rightOn = mOnStack.Pop()

						if(glue.Value == WhereClauseConnector.AndOperator) then
						begin
							mOnStack.Push(leftOn .and. rightOn)
						end
						else if(glue.Value == WhereClauseConnector.OrOperator) then
						begin
							mWhereStack.Push(leftOn .or. rightOn)
						end
						else
							throw new NotImplementedException()

					end
					else
					begin
						data rightWhere = mWhereStack.Pop()
						if(glue.Value == WhereClauseConnector.AndOperator) then
						begin
							mWhereStack.Push(leftOn .and. rightWhere)
						end
						else if(glue.Value == WhereClauseConnector.OrOperator) then
						begin
							mWhereStack.Push(leftOn .or. rightWhere)
						end
						else
							throw new NotImplementedException()
					end
				end
				else
				begin
					Visit(node.Left)
					data leftWhere = mWhereStack.Pop()
					Visit(node.Right)
					data rightWhere = mWhereStack.Pop()

					if(glue.Value == WhereClauseConnector.AndOperator) then
					begin
						mWhereStack.Push(leftWhere .and. rightWhere)
					end
					else if(glue.Value == WhereClauseConnector.OrOperator) then
					begin
						mWhereStack.Push(leftWhere .or. rightWhere)
					end
					else
						throw new NotImplementedException()
				end

			end

			mreturn node
		endmethod
	endclass

endnamespace
