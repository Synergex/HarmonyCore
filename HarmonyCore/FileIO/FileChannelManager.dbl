import System
import System.Collections.Generic
import System.Text
import System.Collections.Concurrent
import Harmony.Core.Utility
import System.Linq
import Microsoft.Extensions.Caching.Memory
import System.Threading
namespace Harmony.Core.FileIO

	public class FileChannelManager implements IFileChannelManager, IDisposable
		; declare a number of xfServer connections
		private static xfConnections, int, 2
		private static counter, int, xfConnections - 1

        public virtual method Dispose, void
            endparams
        proc
            Dispose(true)
        endmethod

        protected virtual method Dispose, void
            disposing, boolean
            endparams
        proc
            data channelTpl, KeyValuePair<int, Tuple<int, Tuple<string, FileOpenMode>>>
            foreach channelTpl in mAllOpenChannels
			    close channelTpl.Key

			data connectionTpl, KeyValuePair<string, int>
			data handle, D_HANDLE
			foreach connectionTpl in mAllOpenConnections
				handle = %DESTROY_SERVER_CONNECTION(connectionTpl.Value)

            if(disposing)
                GC.SuppressFinalize(this)
        endmethod

        method ~FileChannelManager
        proc
            Dispose(false)
        endmethod

        public virtual method AbandonOpenChannels, void
        proc
            mAllOpenChannels.Clear()
        endmethod

        private class ChannelCacheEntry implements IDisposable

            public virtual method Dispose, void
                endparams
            proc
                this.FileChannelManager.CloseFile(FileName)
            endmethod

            public readwrite property FileChannelManager, @FileChannelManager
            public readwrite property FileName, string


        endclass

		public static method GetConnections, int
		proc
			mreturn xfConnections
		endmethod
				
		public static class LoadInfo
			static AsyncLocalLoad, @AsyncLocal<int>, new AsyncLocal<int>()
			public static method SetLoadId, void
				lid, int
			proc
				AsyncLocalLoad.Value = lid
			endmethod
			public static property CurrentLoadId, int
				method get
				proc
					mreturn AsyncLocalLoad.Value
				endmethod
			endproperty
		endclass

		private class Connections
			private lid, int
			private server, @string
			private port, int

		endclass

		private method RemoteFile, boolean
			fileName, @string
		proc
			data envVar, @string, ""
			data sep, int
			sep = fileName.IndexOf(":", StringComparison.Ordinal)
			if (sep > 0)
				envVar = fileName.Substring(0, sep)
			envVar = Environment.GetEnvironmentVariable(envVar)
			if (envVar)
				if(envVar.Contains('@'))
					mreturn true
			mreturn false
		endmethod

		private method GetEnvVar, string
			fileName, @string
		proc
			data envVar, @string, ""
			data sep, int
			sep = fileName.IndexOf(":", StringComparison.Ordinal)
			if (sep > 0)
				envVar = fileName.Substring(0, sep)
			mreturn envVar
		endmethod		

		private method GetServerName, string
			fileName, @string
		proc
			data serv, @string, ""
			if (RemoteFile(fileName))
			begin
				data envVar, @string
				data sep, int
				sep = fileName.IndexOf(":", StringComparison.Ordinal)
				if (sep > 0)
					envVar = fileName.Substring(0, sep)
				envVar = Environment.GetEnvironmentVariable(envVar)
				serv = envVar.Substring(envVar.LastIndexOf('@') + 1)
			end
			mreturn serv
		endmethod

		private method GetPortNumber, string
			fileName, @string
		proc
			data port, @string
			if (RemoteFile(fileName))
			begin
				port = Environment.GetEnvironmentVariable("SCSPORT")
				if (!port)
					port = "2330"		
			end
			mreturn port
		endmethod

		private method GetFileName, string
			fileName, @string
		proc
			data newFileName, @string
			if (RemoteFile(fileName))
			begin
				data envVar, @string
				data file, @string
				data sep, int
				sep = fileName.IndexOf(":", StringComparison.Ordinal)
				if (sep > 0)
				begin
					file = fileName.Substring(sep)
					envVar = fileName.Substring(0, sep)
					envVar = Environment.GetEnvironmentVariable(envVar)
					if (envVar) then
					begin
						sep = envVar.IndexOf(":", StringComparison.Ordinal)
						envVar = envVar.Substring(0, sep)
						if (sep > 0)
							newFileName = envVar + file
					end
					else
						newFileName = fileName
				end
			end
			mreturn newFileName
		endmethod

        private method MakeCacheEntry, @FileChannelManager.ChannelCacheEntry
            fileName, @string
        proc
            mreturn new ChannelCacheEntry() { FileChannelManager = this, FileName = fileName }
        endmethod

		protected mAllOpenConnections, @ConcurrentDictionary<string, int>, new ConcurrentDictionary<string, int>()
		protected mAllOpenChannels, @ConcurrentDictionary<int, Tuple<int, Tuple<string, FileOpenMode>>>, new ConcurrentDictionary<int, Tuple<int, Tuple<string, FileOpenMode>>>()
        protected mChannelLookup, @ConcurrentDictionary<int, ConcurrentDictionary<string, ConcurrentDictionary<FileOpenMode, ConcurrentBag<int>>>>, new ConcurrentDictionary<int, ConcurrentDictionary<string, ConcurrentDictionary<FileOpenMode, ConcurrentBag<int>>>>()
        protected mChannelLRU, @BitFaster.Caching.Lru.FastConcurrentLru<string, FileChannelManager.ChannelCacheEntry>, new BitFaster.Caching.Lru.FastConcurrentLru<string, ChannelCacheEntry>(SoftChannelLimit)
        public static readwrite property SoftChannelLimit, int, 512

        public virtual method GetChannel, int
            fileName, @string
            openMode, FileOpenMode
        proc
			if (RemoteFile(fileName)) then
			begin
				counter = Interlocked.Increment(counter)
				LoadInfo.SetLoadId((counter .mod. xfConnections) + 1)
			end
			else
				LoadInfo.SetLoadId(0)

			(void)mChannelLRU.GetOrAdd(fileName, MakeCacheEntry) ;;signal the cache that this filename was hit
			data loadIdLookup = mChannelLookup.GetOrAdd(LoadInfo.CurrentLoadId, lambda(keyValue) {  new ConcurrentDictionary<string, ConcurrentDictionary<FileOpenMode, ConcurrentBag<int>>>() })
			data fileModeLookup = loadIdLookup.GetOrAdd(fileName, lambda(keyValue) { new ConcurrentDictionary<FileOpenMode, ConcurrentBag<int>>() })
            data fileChannelBag = fileModeLookup.GetOrAdd(openMode, lambda(keyValue) { new ConcurrentBag<int>() })
            data channel, int, 0
            if(fileChannelBag.TryTake(channel)) then
                mreturn channel
            else
            begin
               channel = OpenChannel(fileName, openMode)
                mreturn channel
            end
			
        endmethod
		
        protected virtual method OpenChannel, int
            fileName, @string
            openMode, FileOpenMode
        proc
			data handle, D_HANDLE
			data channel, i4, 0
			data remoteFileName, @string, ""
			data envVar, @string, ""
			data envVarTranslation, @string, ""
			data envVarLength, int, 0

			try
			begin
				if (RemoteFile(fileName))
				begin
					data server, @string
					data port, @string

					server = GetServerName(fileName)
					port = GetPortNumber(fileName)
					
					try
					begin
						if (!mAllOpenConnections.TryGetValue(server, handle))
						begin
							Monitor.Enter(mAllOpenConnections)
							handle = mAllOpenConnections.GetOrAdd(server, %create_server_connection(server, Int32.Parse(port)))
						end
					end
					finally
					begin
							if (RemoteFile(fileName) .and. Monitor.IsEntered(mAllOpenConnections))
							begin
								Monitor.Exit(mAllOpenConnections)
							end
					end
					endtry
				end

                using openMode select
                (FileOpenMode.UpdateRelative),
                begin
					if (handle) then
						open(channel, 'u:r', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'u:r', fileName)
                end
                (FileOpenMode.Update, FileOpenMode.UpdateIndexed),
				begin
					if (handle) then
						open(channel, 'u:i', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'u:i', fileName)
                end
                (FileOpenMode.InputSequential),
				begin
					if (handle) then
						open(channel, 'i:s', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'i:s', fileName)
                end
                (FileOpenMode.InputRelative),
				begin
					if (handle) then
						open(channel, 'i:r', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'i:r', fileName)
                end
                (FileOpenMode.OutputSequential),
                begin
					if (handle) then
						open(channel, 'o:s', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'o:s', fileName)
                end
                (FileOpenMode.Input,FileOpenMode.InputIndexed),
                begin
					if (handle) then
						open(channel, 'i:i', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'i:i', fileName)
                end
                (FileOpenMode.AppendSequential),
				begin
					if (handle) then
						open(channel, 'a:s', GetFileName(fileName), SERVERCONNECTION:handle)
					else
						open(channel, 'a:s', fileName)
                end
                endusing
			
                DebugLogSession.Logging.LogInfo("FileChannelManager: Opened channel {0} with mode {1} using path {2}", channel, openMode, fileName)
				
				mAllOpenChannels[channel] = Tuple.Create(LoadInfo.CurrentLoadId, Tuple.Create(fileName, openMode))

                mreturn channel
            end
            catch(ex, @NoFileFoundException)
            begin
                DebugLogSession.Logging.LogInfo("FileChannelManager: failed to open channel {0} with mode {1} using path {2}", channel, openMode, fileName)
                throw
			end
            endtry
            throw new ApplicationException("impossible execution")
        endmethod

        public virtual method ReturnChannel, void
            channelId, int
        proc
            DebugLogSession.Logging.LogInfo("FileChannelManager: Returned channel {0}", channelId)
            xcall free(channelId)
			data loadInfo, @Tuple<int, Tuple<string, FileOpenMode>>

			if(!mAllOpenChannels.TryGetValue(channelId, loadInfo)) then
            begin
                close channelId
            end
            else
            begin
				data loadIdLookup = mChannelLookup[loadInfo.Item1]
				data fileInfo = loadInfo.Item2
				data openModeLookup = loadIdLookup[fileInfo.Item1]
				data channelBag = openModeLookup[fileInfo.Item2]
				channelBag.Add(channelId)
            end

        endmethod

        ;;returns the number of channels closed
        public virtual method CloseFile, int
            fileName, @string
        proc
            data closedChannelCount = 0
            data openDictionary, @ConcurrentDictionary<FileOpenMode, ConcurrentBag<int>>
			data fileNameLookup = mChannelLookup[LoadInfo.CurrentLoadId]
			if(fileNameLookup.TryGetValue(fileName, openDictionary))
            begin
                data openDictionaryItem, @KeyValuePair<FileOpenMode, ConcurrentBag<int>>
                foreach openDictionaryItem in openDictionary
                begin
                    data targetChannel, int
                    data bag, @ConcurrentBag<int>, openDictionaryItem.Value
                    while(bag.TryTake(targetChannel))
                    begin
                        DebugLogSession.Logging.LogInfo("FileChannelManager: Closed channel {0}", targetChannel)
                        incr closedChannelCount
                        close targetChannel
                    end
                end
            end
            mreturn closedChannelCount
        endmethod


        public virtual method ChannelHasHook, boolean
            channelId, int
        proc
            mreturn false
        endmethod

        public virtual method ChannelHookType, @Type
            channelId, int
        proc
            mreturn ^null
        endmethod
    endclass

endnamespace
