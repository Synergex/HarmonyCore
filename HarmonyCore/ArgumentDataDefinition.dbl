;//****************************************************************************
;//
;// Title:       ArgumentDataDefinition.dbl
;//
;// Type:        Class
;//
;// Description: Define the argument data
;//
;// Author:      Richard C. Morris, Synergex Technology Evengelist
;//
;// Copyright (c) 2014, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;//****************************************************************************

import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import Harmony.Core.Enumerations
import Harmony.Core.Converters
import Newtonsoft.Json.Linq

namespace Harmony.Core

    public class ArgumentDataDefinition
        public PassedValue			,@Object
        public ReturnedValue		,boolean?
        public DataType				,FieldDataType
        public ElementSize			,int?
        public DecimalPrecision		,int?
    endclass

    public class ReturnParameterDefintion
        public Position, int
        {JsonConverter(^typeof(ReturnValueConverter))}
        public Value, @ArgumentDataDefinition
    endclass

    public class ReturnValueConverter extends JsonConverter

        public override method CanConvert, boolean
            type, @Type
        proc
            mreturn true
        endmethod


        public override property CanRead, boolean
            method get
            proc
                mreturn true
            endmethod
        endproperty

        public override method WriteJson, void 
            writer, @JsonWriter
            value, @object
            serializer, @JsonSerializer
        proc
		
            throw new NotImplementedException()
        endmethod

        public override method ReadJson, @object 
            reader, @JsonReader 
            objectType, @Type 
            existingValue, @object 
            serializer, @JsonSerializer 
        proc
            data result = new ArgumentDataDefinition()
            data jObj = JObject.Load(reader)
            data dataTypeField = jObj["DataType"]
            if(dataTypeField != ^null)
            begin
                result.DataType = (FieldDataType)dataTypeField.Value<long>()
                result.ReturnedValue = true
                if(result.DataType == FieldDataType.DataObjectField) then
                begin
                    data dataObjectValue = jObj["PassedValue"]
                    if(dataObjectValue == ^null)
                        throw new InvalidCastException()

                    data metadataType = DataObjectMetadataBase.LookupType((string)dataObjectValue["Type"])

                    data grfa = (string)dataObjectValue["GRFA"]
                    data realValue = dataObjectValue.Value<string>((Object)"Value")
                    if(realValue == ^null) then
                    begin
                        result.PassedValue = metadataType.MakeNew((a)Convert.FromBase64String(dataObjectValue.Value<string>((Object)"Base64Value")), grfa)
                    end
                    else
                    begin
                        result.PassedValue = metadataType.MakeNew(realValue, grfa)
                    end
                end
                else if(result.DataType == FieldDataType.DataObjectCollectionField) then
                begin
                    data metadataType, @DataObjectMetadataBase
                    data tempResultDO = new List<DataObjectBase>()
                    data tempResultObject = new List<Object>()
                    data dataObjectValues = (@JArray)jObj["PassedValue"]
                    data dataObjectToken, @JToken
                    data dataObjectValue, @JObject
                    foreach dataObjectToken in dataObjectValues
                    begin
                        if(dataObjectToken .is. JObject) then
                        begin
                            if(metadataType == ^null)
                                metadataType = DataObjectMetadataBase.LookupType((string)dataObjectValue["Type"])

                            data grfa = (string)dataObjectValue["GRFA"]
                            data realValue = dataObjectValue.Value<string>((Object)"Value")
                            if(realValue == ^null) then
                            begin
                                tempResultDO.Add(metadataType.MakeNew((a)Convert.FromBase64String(dataObjectValue.Value<string>((Object)"Base64Value")), grfa))
                            end
                            else
                            begin
                                tempResultDO.Add(metadataType.MakeNew(realValue, grfa))
                            end
                        end
                        else
                        begin
                            using dataObjectToken.Type select
                            (JTokenType.Null),
                                tempResultObject.Add(^null)
                            (JTokenType.Integer),
                                tempResultObject.Add((@object)dataObjectToken.ToObject<int>())
                            (JTokenType.Float),
                                tempResultObject.Add((@object)dataObjectToken.ToObject<float>())
                            (JTokenType.Bytes),
                                tempResultObject.Add((@object)dataObjectToken.ToObject<[#]byte>())
                            (JTokenType.Boolean),
                                tempResultObject.Add((@object)dataObjectToken.ToObject<boolean>())
                            (JTokenType.String),
                                tempResultObject.Add((@object)dataObjectToken.ToObject<string>())
                            endusing
                        end
                    end

                    result.PassedValue = tempResultDO.Count > 0 ? tempResultDO : tempResultObject
                end
                else
                begin
                    result.PassedValue = jObj["PassedValue"]
                end
            end

            mreturn result
        endmethod

    endclass

endnamespace
