import System
import System.Collections.Generic
import System.Text
import System.Diagnostics
import Newtonsoft.Json
import Newtonsoft.Json.Linq
import System.Threading.Tasks


namespace Harmony.Core.Context

	public class ProcessDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetProcess, @Process
        private mMakeReadyTask, @Lazy<Task>
		public method ProcessDynamicCallConnection
			startInfo, @ProcessStartInfo
		proc
			mTargetProcess = new Process()
			mTargetProcess.StartInfo = startInfo
            mMakeReadyTask = new Lazy<Task>(MakeReadyInternal)
		endmethod

		public async virtual method ReadRaw, @Task<string>
			terminator, Char 
			endparams
        proc
            await mMakeReadyTask.Value
			if(terminator != %char(13))
				throw new NotImplementedException("the only acceptable terminator for this connection type is newline")

			data lengthBuffer = new char[10]
			mTargetProcess.StandardOutput.ReadBlock(lengthBuffer, 0, 10)
			try
			begin
				data expectedMessageLength = Convert.ToInt32(new string(lengthBuffer))
                data messageBuffer = new char[expectedMessageLength]
                ;;TODO error control around this returned length
				await mTargetProcess.StandardOutput.ReadBlockAsync(messageBuffer, 0, expectedMessageLength)
				mreturn new string(messageBuffer)
			end
			catch(ex, @Exception)
			begin
				mreturn new string(lengthBuffer) + mTargetProcess.StandardOutput.ReadLine()
			end
			endtry
		endmethod
		
		public virtual method Recycle, @Task
			endparams
		proc
			mreturn Task.FromResult(true)
		endmethod
				
		public virtual method Disconnect, void
			endparams
		proc
			mTargetProcess.Kill()
		endmethod
		
		class ProtocolMessage
			public readwrite property ProtocolSupported, boolean
		endclass


		private async method MakeReadyInternal, @Task
			endparams
		proc
			data handshakeString = '{"ProtocolVersion":"1.0"}'
			data readLine, @string
			mTargetProcess.Start()
			mTargetProcess.StartInfo.StandardOutputEncoding = ASCIIEncoding.ASCII
			while((readLine = mTargetProcess.StandardOutput.ReadLine()) != "READY")
			begin
				Debug.WriteLine("Not Ready")
			end
			data paddedLengthString = handshakeString.Length.ToString().PadLeft(10, '0')
			data tempBytes = ASCIIEncoding.ASCII.GetBytes(paddedLengthString + %char(10) + %char(13))
			mTargetProcess.StandardInput.BaseStream.Write(tempBytes, 0, tempBytes.Length)
			mTargetProcess.StandardInput.BaseStream.Flush()
			data response = mTargetProcess.StandardOutput.ReadLine()
			tempBytes = ASCIIEncoding.ASCII.GetBytes(handshakeString + %char(10) + %char(13))
			mTargetProcess.StandardInput.BaseStream.Write(tempBytes, 0, tempBytes.Length)
			mTargetProcess.StandardInput.BaseStream.Flush()
			data lengthBuffer = new char[10]
			mTargetProcess.StandardOutput.ReadBlock(lengthBuffer, 0, 10)
			data expectedMessageLength = Convert.ToInt32(new string(lengthBuffer))
			data messageBuffer = new char[expectedMessageLength]
			mTargetProcess.StandardOutput.ReadBlock(messageBuffer, 0, expectedMessageLength)
			;;TODO real json here
			data deserializedMessage = JsonConvert.DeserializeObject<ProtocolMessage>(new string(messageBuffer))
			if(!deserializedMessage.ProtocolSupported)
				throw new Exception("Protocol not supported")
		endmethod
		
		public async virtual method WriteRaw, @Task
			rawData, [#]byte
			endparams
        proc
            await mMakeReadyTask.Value
			data paddedLengthString = rawData.Length.ToString().PadLeft(10, '0')
			data tempBytes = ASCIIEncoding.ASCII.GetBytes(paddedLengthString + %char(10) + %char(13))
			await mTargetProcess.StandardInput.BaseStream.WriteAsync(tempBytes, 0, tempBytes.Length)
			await mTargetProcess.StandardInput.BaseStream.FlushAsync()
			data response = await mTargetProcess.StandardOutput.ReadLineAsync()
			await mTargetProcess.StandardInput.BaseStream.WriteAsync(rawData, 0, rawData.Length)
			await mTargetProcess.StandardInput.BaseStream.WriteAsync(NewLineBytes, 0, NewLineBytes.Length)
			await mTargetProcess.StandardInput.BaseStream.FlushAsync()
			
		endmethod
	
        public virtual method MakeReady, @Task
        proc
            mreturn mMakeReadyTask.Value
        endmethod


	endclass

endnamespace
