import System
import System.Collections.Generic
import System.Text
import System.Diagnostics
import Newtonsoft.Json
import Newtonsoft.Json.Linq
import System.Threading.Tasks
import StreamJsonRpc
import System.IO
import System.Threading
import System.Linq
import Harmony.Core.Utility
import Nerdbank.Streams

namespace Harmony.Core.Context

	public class ProcessDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetProcess, @Process
		private mProcessStarted, boolean, false
		private mLocalRPCHandlers, @Dictionary<string, Delegate> 
		private mMakeReadyTask, @Lazy<Task<JsonRpc>>
		private mDisconnectToken, @CancellationTokenSource
		private mLastSeenBytes, ArraySegment<byte>

		public method ProcessDynamicCallConnection
			startInfo, @ProcessStartInfo
		proc
			mTargetProcess = new Process()
			mTargetProcess.StartInfo = startInfo
			mLocalRPCHandlers = new Dictionary<string, Delegate>()
			mMakeReadyTask = new Lazy<Task<JsonRpc>>(MakeReadyInternal)
			mDisconnectToken = new CancellationTokenSource()
			IsHealthy = true
		endmethod

		public readwrite property IsHealthy, boolean

		public virtual method Recycle, @Task
			endparams
		proc
			mreturn Task.FromResult(true)
		endmethod
				
		public virtual async method Disconnect, @Task
			endparams
		proc
			try
			begin
				if(mProcessStarted && !mTargetProcess.HasExited)
				begin
					await this.Notify("rpc.shutdown", new ArgumentDataDefinition[0])
					mDisconnectToken.Cancel()
					await Task.Delay(100)
					if(!mTargetProcess.HasExited)
						mTargetProcess.Kill()
				end

			end
			catch(ex, @Exception)
			begin
				DebugLogSession.Logging.LogException(ex, "ProcessDynamicCallConnection-Disconnect")
			end
			endtry
		endmethod
		
		class ProtocolMessage
			public readwrite property ProtocolSupported, boolean
		endclass

		public virtual async method Call, @Task<[#]@ReturnParameterDefintion>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data jsonRpcConnection = await mMakeReadyTask.Value
			try
			begin
				mreturn await jsonRpcConnection.InvokeWithCancellationAsync<[#]@ReturnParameterDefintion>(name, args.OfType<Object>().ToList().AsReadOnly(), mDisconnectToken.Token)
			end
			catch(ex, @StreamJsonRpc.ConnectionLostException)
            begin
                IsHealthy = false
				;;this will be empty if trace level logging is not turned on in order to prevent leaking sensitive data in production environments
				if(mLastSeenBytes.Count > 0) then
                    throw new StreamJsonRpc.ConnectionLostException("The JSON-RPC connection with the remote party was lost before the request could complete. Last seen bytes passed: '" + Encoding.UTF8.GetString(mLastSeenBytes).Replace(%char(10), "<LF>").Replace(%char(13), "<CR>") + "'", ex)
                else
					throw
			end
			catch(ex, @RemoteInvocationException)
			begin
				if(ex.ErrorCode == -32000)
					IsHealthy = false

				throw new BridgeException(ex)
			end
			catch(ex, @RemoteMethodNotFoundException)
			begin
				throw new BridgeException(ex)
			end
			catch(ex, @Exception)
			begin
				IsHealthy = false
				throw
			end
			endtry
		endmethod

		public virtual async method Notify, @Task
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data jsonRpcConnection = await mMakeReadyTask.Value
			await jsonRpcConnection.NotifyAsync(name, args.OfType<Object>().ToArray())
		endmethod

		public method AddLocalRpcMethod, void
			name, @string
			handler, @Delegate
		proc
			if(!mLocalRPCHandlers.ContainsKey(name))
			begin
				mLocalRPCHandlers.Add(name, handler)
				if(mMakeReadyTask.IsValueCreated && mMakeReadyTask.Value.Status == TaskStatus.RanToCompletion)
				begin
					if(handler.Method.IsStatic) then
						mMakeReadyTask.Value.Result.AddLocalRpcMethod(name, handler.Method, ^null)
					else
						mMakeReadyTask.Value.Result.AddLocalRpcMethod(name, handler.Method, handler.Target)
				end
			end
		endmethod

		private async method MakeReadyInternal, @Task<JsonRpc>
			endparams
		proc
			data readLine, @string
			mTargetProcess.EnableRaisingEvents = true
			mTargetProcess.StartInfo.StandardOutputEncoding = ASCIIEncoding.ASCII
			mTargetProcess.Start()
			mProcessStarted = true
			
			readLine = await mTargetProcess.StandardOutput.ReadLineAsync()
			while(!mTargetProcess.HasExited && readLine != "READY")
			begin
				readLine += await mTargetProcess.StandardOutput.ReadLineAsync()
			end

			if(mTargetProcess.HasExited)
			begin
				data outputText = await mTargetProcess.StandardOutput.ReadToEndAsync()
				outputText = readLine + outputText
				data logs = new string[#] { string.Format(" application: '{0}' arguments: '{1}' working directory: '{2}' stdOut: '{3}'", mTargetProcess.StartInfo.FileName, mTargetProcess.StartInfo.Arguments, mTargetProcess.StartInfo.WorkingDirectory, outputText) }
				if(outputText.Contains("%DBR-F-NOTDBR")) then
				begin
					throw new BridgeConnectionException("TraditionalBridge failed to initialize most likely due to x86/x64 mismatch.", logs)
				end
				else if(outputText.Contains("%DBR-E-OPENF")) then
				begin
					throw new BridgeConnectionException("TraditionalBridge failed to initialize most likely due to missing dbr or elb file.", logs)
				end
				else
				begin
					throw new BridgeConnectionException("TraditionalBridge failed to initialize.", logs)
				end
			end

			mTargetProcess.Exited += ProcessExit

			data formatter = new JsonMessageFormatter(new UTF8Encoding(false))
			formatter.JsonSerializer.FloatParseHandling = FloatParseHandling.Decimal
			
			data targetOutput, @Stream
			data targetInput, @Stream

			;;if the base stream is a filestream lets grab its guts and resize the buffer to 64k
			if(mTargetProcess.StandardInput.BaseStream .is. FileStream) then
			begin
				data inputFileStream = ^as(mTargetProcess.StandardInput.BaseStream, @FileStream)
				data outputFileStream = ^as(mTargetProcess.StandardOutput.BaseStream, @FileStream)

				targetInput = new FileStream(inputFileStream.SafeFileHandle, FileAccess.Write, 4096 * 16, false)
				targetOutput = new FileStream(outputFileStream.SafeFileHandle, FileAccess.Read, 4096 * 16, false)
			end
			else
			begin
				targetInput = mTargetProcess.StandardInput.BaseStream
				targetOutput = mTargetProcess.StandardOutput.BaseStream
			end

			data streamWrapper = FullDuplexStream.Splice(targetOutput, targetInput)
			
			if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Trace)
			begin
				data tempStreamWrapper = new MonitoringStream(streamWrapper)
				tempStreamWrapper.DidRead += StreamReadMonitorEvent
				streamWrapper = tempStreamWrapper
			end

			data result = new JsonRPC(new HeaderDelimitedMessageHandler(streamWrapper, formatter))
            if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Trace)
			begin
				result.TraceSource = new TraceSource("Client", SourceLevels.All)
			end

			data rpcKvp, KeyValuePair<string, Delegate>
			foreach rpcKvp in mLocalRPCHandlers
			begin
				if(rpcKvp.Value.Method.IsStatic) then
					result.AddLocalRpcMethod(rpcKvp.Key, rpcKvp.Value.Method, ^null)
				else
					result.AddLocalRpcMethod(rpcKvp.Key, rpcKvp.Value.Method, rpcKvp.Value.Target)
			end

			result.StartListening()
			mreturn result
		endmethod
	
		private method ProcessExit, void
			sender, @Object
			args, @EventArgs
		proc
			IsHealthy = false
			mDisconnectToken.Cancel()
		endmethod


		public virtual method MakeReady, @Task
		proc
			mreturn mMakeReadyTask.Value
		endmethod

		private method StreamReadMonitorEvent, void
			sender, @Object
			bytes, ArraySegment<byte>
		proc
			mLastSeenBytes = bytes
		endmethod

		private class StreamWrapper extends Stream

			public override method Read, int
				buffer, [#]byte 
				offset, int 
				count, int 
				endparams
			proc
				data returnedCount = mReader.BaseStream.Read(buffer, offset, count)
				if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Trace)
				begin
					DebugLogSession.Logging.LogTrace("ProcessDynamicCallConnection read ascii string: {0}", new ASCIIArrayDebugLogHelper(buffer, offset, returnedCount))
				end
				mreturn returnedCount
			endmethod


			private mReader, @StreamReader
			private mWriter, @StreamWriter
			;private mEvent, @AutoResetEvent
			public method StreamWrapper
				reader, @StreamReader
				writer, @StreamWriter
			proc
				mReader = reader
				mWriter = writer
				;mEvent = new AutoResetEvent(false)
			endmethod


			public override property CanRead, Boolean
				method get
				proc
					mreturn mReader.BaseStream.CanRead
				endmethod
			endproperty



			public override method Flush, void
				endparams
			proc
				mWriter.BaseStream.Flush()
			endmethod

			public override async method ReadAsync, @Task<int> 
				buffer, [#]byte 
				offset, int 
				count, int 
				token, CancellationToken
				endparams
			proc
				data readBytes = await mReader.BaseStream.ReadAsync(buffer, offset, count, token)
				if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Trace)
				begin
					DebugLogSession.Logging.LogTrace("ProcessDynamicCallConnection read ascii string: {0}", new ASCIIArrayDebugLogHelper(buffer, offset, Math.Min(50, readBytes)))
				end
				mreturn readBytes
			endmethod


			public override async method WriteAsync, @Task
				buffer, [#]byte
				offset, int
				count, int
				cancellationToken, CancellationToken
			proc
				if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Debug)
				begin
					DebugLogSession.Logging.LogDebug("ProcessDynamicCallConnection write ascii string: {0}", new ASCIIArrayDebugLogHelper(buffer, offset, Math.Min(50, count)))
				end

				await mWriter.BaseStream.WriteAsync(buffer, offset, count, cancellationToken)
				await mWriter.BaseStream.FlushAsync()
			endmethod


			public override property CanTimeout, boolean
				method get
				proc
					mreturn true
				endmethod
			endproperty


			public override property CanSeek, Boolean
				method get
				proc
					mreturn false
				endmethod
			endproperty



			public override property Position, long
				method get
				proc
					mreturn mReader.BaseStream.Position
				endmethod
				method set
				proc
					mReader.BaseStream.Position = value
				endmethod
			endproperty



			public override property Length, long
				method get
				proc
					mreturn mReader.BaseStream.Length
				endmethod
			endproperty



			public override method Seek, long
				offset, long 
				origin, SeekOrigin 
				endparams
			proc
				throw new NotImplementedException()
			endmethod



			public override property CanWrite, Boolean
				method get
				proc
					mreturn true
				endmethod
			endproperty



			public override method Write, void
				buffer, [#]byte 
				offset, int 
				count, int 
				endparams
			proc
				if(DebugLogSession.Logging.Level == Harmony.Core.Interface.LogLevel.Debug)
				begin
					DebugLogSession.Logging.LogDebug("ProcessDynamicCallConnection write ascii string: {0}", new ASCIIArrayDebugLogHelper(buffer, offset, Math.Min(50, count)))
				end
				mWriter.BaseStream.Write(buffer, offset, count)
				mWriter.BaseStream.Flush()
			endmethod



			public override method SetLength, void
				value, long 
				endparams
			proc
				throw new NotImplementedException()
			endmethod
		endclass
	endclass

endnamespace
