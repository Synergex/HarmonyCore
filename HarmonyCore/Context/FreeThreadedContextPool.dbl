import System.Collections.Concurrent
import System
import System.Collections.Generic
import System.Text
import Microsoft.CodeAnalysis.PooledObjects
import System.Threading.Tasks
import Microsoft.Extensions.DependencyInjection
import Harmony.Core.Interface
import Harmony.Core.Utility

namespace Harmony.Core.Context

	public class FreeThreadedContextPool<T(IContextBase, class)> extends ContextFactory<T> implements IContextPool<T>, IDisposable

		public virtual method Dispose, void
			endparams
		proc
			TrimPool(0).Wait()
		endmethod

		public virtual async method RealizeMinimumPoolSize, @Task
			provider, @IServiceProvider
			endparams
		proc
			while(mContextPool.Count < mMinSize)
			begin
				data madeContext, @IContextBase, mContextPool.Allocate(provider)
				if(madeContext .is. IPooledContextBase)
				begin
					await ((@IPooledContextBase)madeContext).EnsureReady()
				end

				mContextPool.Free(madeContext)
			end
		endmethod

		public virtual method TrimPool, @Task
			targetSize, int 
			endparams
		proc
			data asyncDestroyedTasks = new List<Task>()
			while(mContextPool.Count > targetSize)
			begin
				try
				begin
					;;this shouldnt actually perform an allocation
					data context = mContextPool.Allocate(^null)
					if(context .is. IDisposable) then
						((@IDisposable)context).Dispose()
					else if(context .is. IAsyncPooledContextBase) then
					begin
						asyncDestroyedTasks.Add(((@IAsyncPooledContextBase)context).DestroyAsync())
					end
					else if(context .is. IPooledContextBase)
					begin
						((@IPooledContextBase)context).Destroy()
					end
				end
				catch (ex, @Exception)
				begin
					DebugLogSession.Logging.LogException(ex, this.GetType().FullName)
				end
				endtry

			end
			if(asyncDestroyedTasks.Count > 0) then
				mreturn Task.WhenAll(asyncDestroyedTasks)
			else
				mreturn Task.FromResult(true)
		endmethod

		private mMinSize, int
		private mSessionLookup, @ConcurrentDictionary<string, T>
		private mContextPool, @ObjectPool<T>
		public method FreeThreadedContextPool
			min, int
		proc
			mSessionLookup = new ConcurrentDictionary<string, T>()
			mContextPool = new ObjectPool<T>(lambda(provider) { SlowMakeContext(provider) }, min)
			DebugLogSession.Logging.LogInfo("FreeThreadedContextPool<{0}>::ctor with a minimum size of {1}", ^typeof(T).FullName, min)
		endmethod

		public override method MakeContextAsync, @Task<T>
			sessionId, @string 
			provider, @IServiceProvider
			endparams
		proc
			mreturn Task.FromResult(MakeContext(sessionId, provider))
		endmethod
		
		public override method MakeContext, T
			sessionId, @string
			provider, @IServiceProvider
			endparams
		proc
			data result = mContextPool.Allocate(provider)
			if(result .is. IPooledContextBase)
			begin
				((@IPooledContextBase)result).InitServices(provider)
			end
			mreturn result
		endmethod

		protected virtual method SlowMakeContext, T
			provider, @IServiceProvider
		proc
			data logging = provider.GetService<IDebugLogging>() ?? DebugLogSession.Logging
			logging.LogInfo("FreeThreadedContextPool<{0}>::SlowMakeContext", ^typeof(T).FullName)
			mreturn ActivatorUtilities.CreateInstance<T>(provider)
		endmethod

		public override async method ReturnContext, void
			context, T
		proc
			data pooledContext = ^as(context, @IPooledContextBase)
			try
			begin
				if(pooledContext != ^null)
					await pooledContext.Recycle()

				mContextPool.Free(context)
			end
			catch(ex, @Exception)
			begin
				DebugLogSession.Logging.LogException(ex, this.GetType().Name + "ReturnContext")
			end
			endtry
		endmethod
	endclass

endnamespace
