import System
import System.Collections.Generic
import System.Text
import Renci.SshNet
import Renci.SshNet.Common
import System.IO
import Newtonsoft.Json
import System.Diagnostics
import System.Threading.Tasks
import StreamJsonRpc
import System.Threading

namespace Harmony.Core.Context

	public class SSHDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetConnection, @SshClient
		private mTargetShell, @ShellStream
		private mReader, @StreamReader
		private mWriter, @StreamWriter
		private mLaunchCommand, @string
		private mMakeReadyTask, @Lazy<Task<JsonRpc>>
		private mTargetOS, RemoteTargetOS
		public method SSHDynamicCallConnection
			targetOS, RemoteTargetOS
			startInfo, @ConnectionInfo
			command, @string
		proc
			mTargetOS = targetOS
			mLaunchCommand = command
			mTargetConnection = new SshClient(startInfo)
			mMakeReadyTask = new Lazy<Task<JsonRpc>>(MakeReadyInternal)
		endmethod
		
		public virtual method Recycle, @Task
			endparams
		proc
			mreturn Task.FromResult(true)
		endmethod
				
		public virtual method Disconnect, void
			endparams
		proc
			mTargetConnection.Disconnect()
		endmethod

		public virtual async method Call, @Task<[#]@ReturnParameterDefintion>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data jsonRpcConnection = await mMakeReadyTask.Value
			mreturn await jsonRpcConnection.InvokeAsync<[#]@ReturnParameterDefintion>(name, args)
		endmethod

		public async virtual method MakeReadyInternal, @Task<JsonRpc>
			endparams
		proc
			mTargetConnection.Connect()
			mTargetShell = mTargetConnection.CreateShellStream("vt220", 0, 0,0,0, 1024 * 64)
			data streamWrapper = new ShellStreamWrapper(mTargetShell, mTargetConnection)
			mReader = new StreamReader(streamWrapper) 
			mWriter = new StreamWriter(streamWrapper) 
			data guidString, @string, Guid.NewGuid().ToString()
			data guidStrings = new HashSet<string>()
			data readLine, @string
			data foundMatch, boolean, false
			guidStrings.Add(guidString)

			while(String.IsNullOrWhiteSpace(readLine) || readLine != guidString)
			begin
				if(readLine == ^null || !foundMatch)
				begin
					if(mTargetOS == RemoteTargetOS.VMS) then
					begin
						await mWriter.WriteAsync('WRITE SYS$OUTPUT "' + guidString +  '"' + %char(13) + %char(10))
					end
					else
					begin
						await mWriter.WriteAsync('echo "' + guidString +  '"' + %char(13) + %char(10))
					end

					await mWriter.FlushAsync()
				end

				readLine = TrimControlChars(await mReader.ReadLineAsync())
				while(String.IsNullOrWhiteSpace(readLine))
				begin
					readLine = TrimControlChars(await mReader.ReadLineAsync())
				end
				
				data checkString, @string
				foundMatch = false
				foreach checkString in guidStrings
				begin
					if(readLine.Contains(checkString)) 
					begin
						foundMatch = true
						exitloop
					end
				end

				if(!foundMatch)
				begin
					guidString = Guid.NewGuid().ToString()
					guidStrings.Add(guidString)
				end
			end

			
			await mWriter.WriteAsync(mLaunchCommand + %char(13) + %char(10))
			await mWriter.FlushAsync()

			do
			begin
				readLine = TrimControlChars(await mReader.ReadLineAsync())
			end
			until(readLine == "READY")
			
			
			data result = JsonRpc.Attach(streamWrapper, streamWrapper) 
			result.TraceSource = new TraceSource("Client", SourceLevels.All)
			mreturn result
		endmethod
	
		public method TrimControlChars, @string
			arg, @string
		proc
			if(arg == ^null)
				mreturn ^null

			data arrForm = arg.ToCharArray()
			data buffer = new StringBuilder(arg.Length)
			data ch, char
			foreach ch in arrForm
				if (!Char.IsControl(ch) && !Char.IsWhiteSpace(ch)) 
					buffer.Append(ch)
 
			mreturn buffer.ToString()
		endmethod



		public virtual method MakeReady, @Task
		proc
			mreturn mMakeReadyTask.Value
		endmethod

		private class ShellStreamWrapper extends Stream

			public override method Read, int
				buffer, [#]byte 
				offset, int 
				count, int 
				endparams
			proc
				mreturn mStream.Read(buffer, offset, count)
			endmethod


			private mStream, @ShellStream
			private mConnection, @SshClient
			;private mEvent, @AutoResetEvent
			public method ShellStreamWrapper
				stream, @ShellStream
				connection, @SshClient
			proc
				mStream = stream
				mConnection = connection
				;mEvent = new AutoResetEvent(false)
			endmethod


			public override property CanRead, Boolean
				method get
				proc
					mreturn mStream.CanRead
				endmethod
			endproperty



			public override method Flush, void
				endparams
			proc
				mStream.Flush()
			endmethod

			public override method ReadAsync, @Task<int> 
				buffer, [#]byte 
				offset, int 
				count, int 
				token, CancellationToken
				endparams
			proc
				
				if(mStream.DataAvailable) then
					mreturn Task.FromResult(mStream.Read(buffer, offset, count))
				else
				begin
					data tcs = new TaskCompletionSource<int>()
					data handlerInstance, @EventHandler<ShellDataEventArgs>
					lambda DataReceivedHandler(sender, args)
					begin
						mStream.DataReceived -= handlerInstance
						tcs.TrySetResult(mStream.Read(buffer, offset, count))
					end

					data errorHandlerInstance, @EventHandler<ExceptionEventArgs>
					lambda ErrorHandler(sender, args)
					begin
						mStream.ErrorOccurred -= errorHandlerInstance
						tcs.TrySetException(args.Exception)
					end
					handlerInstance = DataReceivedHandler
					errorHandlerInstance = ErrorHandler
					mStream.DataReceived += handlerInstance
					mConnection.ErrorOccurred += errorHandlerInstance
					mreturn tcs.Task
				end
			endmethod

			public override property CanTimeout, boolean
				method get
				proc
					mreturn true
				endmethod
			endproperty


			public override property CanSeek, Boolean
				method get
				proc
					mreturn mStream.CanSeek
				endmethod
			endproperty



			public override property Position, long
				method get
				proc
					mreturn mStream.Position
				endmethod
				method set
				proc
					mStream.Position = value
				endmethod
			endproperty



			public override property Length, long
				method get
				proc
					mreturn mStream.Length
				endmethod
			endproperty



			public override method Seek, long
				offset, long 
				origin, SeekOrigin 
				endparams
			proc
				mreturn mStream.Seek(offset, origin)
			endmethod



			public override property CanWrite, Boolean
				method get
				proc
					mreturn mStream.CanWrite
				endmethod
			endproperty



			public override method Write, void
				buffer, [#]byte 
				offset, int 
				count, int 
				endparams
			proc
				mStream.Write(buffer, offset, count)
				mStream.Flush()
			endmethod



			public override method SetLength, void
				value, long 
				endparams
			proc
				mStream.SetLength(value)
			endmethod


		endclass

	endclass

endnamespace
