import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import Harmony.Core
import Newtonsoft.Json.Linq
import System.Linq
import System.Reflection
import System.Threading.Tasks

namespace Harmony.Core.Context

	public abstract class DynamicCallProvider implements IDynamicCallProvider
		
		class CallFrame
			public readwrite property Name, @string
			public readwrite property Arguments, [#]@ArgumentDataDefinition
		endclass


		class MethodCallResponseValue
			public readwrite property ReturnParameters, @List<ReturnParameterDefintion>
		endclass

		class MethodCallResponse
			public readwrite property IsError, boolean
			public readwrite property Exception, @string
			public readwrite property Result, @MethodCallResponseValue
		endclass

		private static CastMethodInfo, @MethodInfo

		static method DynamicCallProvider
		proc
			CastMethodInfo = ^typeof(Enumerable).GetMethod("Cast")
        endmethod


		protected connection, @IDynamicCallConnection
		public readonly property IsolationLevel, ContextIsolationLevel
		protected method DynamicCallProvider
			connection, @IDynamicCallConnection
		proc
			this.connection = connection
		endmethod

		public async virtual method CallMethod<T>, @Task<Tuple<T, [#]@Object>>
			name, @string
			{ParamArray}
			args, [#]@object 
			endparams
		proc
            data argsTemp = args
			data arguments, [#]@ArgumentDataDefinition, new ArgumentDataDefinition[args.Length + 1]
			data i, int, 0
			for i from 1 thru args.Length
			begin
				data arg = PreSerializeArgument(args[i])
				arguments[i + 1] = arg
			end

			arguments[1] = new ArgumentDataDefinition() { PassedValue = ^null, ReturnedValue = true }

			data returnType = ^typeof(T)
            if(returnType.IsPrimitive) then
				arguments[1].DataType = FieldDataType.IntegerField
			else if(returnType == ^typeof(string)) then
				arguments[1].DataType = FieldDataType.AlphaField
			else
				arguments[1].DataType = FieldDataType.DataObjectField

			arguments = await CallMethodImplementation(name, arguments)

			for i from 1 thru args.Length
			begin
				if(arguments[i + 1].ReturnedValue != ^null && arguments[i + 1].ReturnedValue.Value)
				begin
					data argValue = arguments[i + 1]
					if(argValue.PassedValue .is. JToken) then
                    begin
						data targetToken = ((@JToken)argValue.PassedValue)
						argsTemp[i] = targetToken.ToObject(argsTemp[i].GetType())
					end
					else
					begin
						if(argValue.DataType == FieldDataType.DataObjectField) then
						begin
							argsTemp[i] = argValue.PassedValue
						end
						else if(argValue.DataType == FieldDataType.DataObjectCollectionField) then
						begin
							data tempCollection = (@IEnumerable<DataObjectBase>)argValue.PassedValue
                            ;;TODO replace this with a generic element getter
							data argType = args[i].GetType().GetGenericArguments()[1]
							argsTemp[i] = CastMethodInfo.MakeGenericMethod(new Type[#] { argType }).Invoke(^null, new object[#] { tempCollection })
						end
						else
						begin
							argsTemp[i] = Convert.ChangeType(argValue.PassedValue, argsTemp[i].GetType())
						end

					end
				end
			end

			if(arguments[1].PassedValue .is. JToken) then
			begin
				data retValue = ((@JToken)arguments[1].PassedValue)
				mreturn Tuple.Create(retValue.Value<T>(), argsTemp)
			end
			else
			begin
				mreturn Tuple.Create((T)Convert.ChangeType(arguments[1].PassedValue,^typeof(T)), argsTemp)
			end
		endmethod
		
        public async virtual method CallMethodV, @Task<[#]@object>
			name, @string
			{ParamArray}
			args, [#]@object 
			endparams
		proc
			data argsTemp = args
			data arguments, [#]@ArgumentDataDefinition, new ArgumentDataDefinition[args.Length]
			data i, int, 0
			for i from 1 thru args.Length
			begin
				data arg = PreSerializeArgument(args[i])
				arguments[i] = arg
			end

			;;TODO check identities of objects to potentially write back
			arguments = await CallMethodImplementation(name, arguments)

			for i from 1 thru args.Length
			begin
				if(arguments[i].ReturnedValue != ^null && arguments[i].ReturnedValue.Value)
				    argsTemp[i] = arguments[i].PassedValue
			end

			mreturn argsTemp
		endmethod

		private method PreSerializeIEnumerable, @object
			argValue, @System.Collections.IEnumerable
		proc
			data result = new List<object>()
			data objValue, @Object
			foreach objValue in argValue
			begin
				result.Add(PreSerializeArgument(objValue).PassedValue)
			end
			mreturn result
		endmethod


		protected virtual method PreSerializeArgument, @ArgumentDataDefinition
			argValue, @Object
		proc
			data argDef = new ArgumentDataDefinition()
				
			if(argValue .is. DataObjectBase) then
			begin
				data doValue = (@DataObjectBase)argValue
				argDef.DataType = FieldDataType.DataObjectField
				;;we might want to convert to base64 here for the value and grfa
				lambda preSerializeDataObject(alphaData, grfaData)
				begin
					data dict = new Dictionary<string, object>()
					dict.Add("Type", doValue.Metadata.RPSStructureName)
					dict.Add("Value", Convert.ToBase64String(([#]byte)alphaData))
					dict.Add("GRFA", Convert.ToBase64String(([#]byte)grfaData))
					argDef.PassedValue = dict
				end
				doValue.InternalSynergyRecord(preSerializeDataObject)
			end
			else if(argValue .is. @String) then
			begin
				argDef.DataType = FieldDataType.AlphaField
				argDef.PassedValue = argValue
			end
			else if(argValue .is. System.Collections.IEnumerable) then
			begin
				argDef.DataType = FieldDataType.DataObjectCollectionField
				argDef.PassedValue = PreSerializeIEnumerable((@System.Collections.IEnumerable)argValue)
			end
			else if(argValue .is. @a) then
			begin
				argDef.DataType = FieldDataType.AlphaField
				;;we might want to convert to base64 here for the value
				argDef.PassedValue = argValue
			end
			else if(argValue .is. @d) then
			begin
				argDef.DataType = FieldDataType.DecimalField
				argDef.PassedValue = argValue.ToString()
			end
			else if(argValue .is. @id) then
			begin
				argDef.DataType = FieldDataType.ImpliedDecimal
				argDef.PassedValue = argValue.ToString()
			end
			else if(argValue .is. @i) then
			begin
				argDef.DataType = FieldDataType.IntegerField
				argDef.PassedValue = argValue
			end
			else if(argValue .is. double || argValue .is. float || argValue .is. decimal) then
			begin
				argDef.DataType = FieldDataType.ImpliedDecimal
				argDef.PassedValue = Convert.ToString(argValue)
				argDef.DecimalPrecision = 28
				argDef.ElementSize = 56
			end
			else if(argValue .is. byte || argValue .is. sbyte || argValue .is. char || argValue .is. short || argValue .is. ushort || argValue .is. int || argValue .is. uint || argValue .is. long || argValue .is. ulong) then
			begin
				argDef.DataType = FieldDataType.IntegerField
				argDef.PassedValue = argValue
			end
			else
				throw new NotImplementedException()

			mreturn argDef
		endmethod

		protected static SerializerSettings, @JsonSerializerSettings, new JsonSerializerSettings() { NullValueHandling=NullValueHandling.Ignore }
		protected async method CallMethodImplementation, @Task<[#]@ArgumentDataDefinition>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			;;build message with method name and serialized parameters
			;;sent frame size followed by message body
			;;check for errors in the response
			;;translate errors locally
			;;deserialize contents
			;;assign return value if there is one
			;;write into args array if the argument values are present in the payload
			data serializedData = JsonConvert.SerializeObject(new CallFrame() { Arguments = args, Name = name }, SerializerSettings)
			data serializedBytes = Encoding.ASCII.GetBytes(serializedData)
			await connection.WriteRaw(serializedBytes)
			data responseBytes = await connection.ReadRaw(%char(13))
			data responseObject = JsonConvert.DeserializeObject<MethodCallResponse>(responseBytes)
			data writableArgs = args
            if(responseObject.IsError) then
				throw new Exception(responseObject.Exception)
			else if(responseObject.Result.ReturnParameters != ^null)
			begin
				data retArg, @ReturnParameterDefintion
				foreach retArg in responseObject.Result.ReturnParameters
				begin
					writableArgs[retArg.Position + 1].ReturnedValue = true
					writableArgs[retArg.Position + 1].PassedValue = retArg.Value.PassedValue
				end
			end
			mreturn writableArgs

		endmethod
	endclass

endnamespace
