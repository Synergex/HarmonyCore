;;*****************************************************************************
;;
;; Title:       OrderMetaData.dbl
;;
;; Type:        Class
;;
;; Description: Defines meta data associated with a data object Order.
;;
;;*****************************************************************************
;; WARNING
;;
;; This file was code generated. Avoid editing this file, as any changes that
;; you make will be lost of the file is re-generated.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System
import System.Collections.Generic
import System.Text
import Harmony.Core
import Harmony.Core.Converters

namespace SampleServices.Models

	.include "ORDERS" repository  , structure="strOrder", end

	;;; <summary>
	;;; 
	;;; </summary>
	public partial class OrderMetadata extends DataObjectMetadataBase
		
		;;; <summary>
		;;; Constructs an new OrderMetadata object.
		;;; </summary>
		public method OrderMetadata
		proc
			RPSStructureName = "ORDERS"
			RPSStructureSize = ^size(strOrder)
			AddFieldInfo("OrNumber", "DECIMAL", 6, 1, 0, false)
			AddFieldInfo("OrVendor", "DECIMAL", 6, 7, 0, false)
			AddFieldInfo("OrItem", "DECIMAL", 6, 13, 0, false)
			AddFieldInfo("OrCustomer", "DECIMAL", 6, 19, 0, false)
			AddFieldInfo("OrQty", "DECIMAL", 6, 25, 0, false)
			AddFieldInfo("OrPrice", "IMPLIED", 7, 31, 02, false)
			AddFieldInfo("OrTerms", "ALPHA", 2, 38, 0, false)
			AddFieldInfo("OrOdate", "DATE", 8, 40, 0, false)
			AddFieldInfo("OrSdate", "DATE", 8, 48, 0, false)
			AddFieldInfo("OrEdate", "DATE", 8, 56, 0, false)
			AddFieldInfo("OrInvoice", "DECIMAL", 7, 64, 0, false)
			AddFieldInfo("TagCustomerLiteral1", "TAG_LITERAL", 0, 0, 0, false,"0")
			AddFieldInfo("TagVendorLiteral1", "TAG_LITERAL", 0, 0, 0, false,"1")

			AddKeyInfo(0, "OrNumber")
			AddKeyInfo(1, "OrVendor")
			AddKeyInfo(2, "OrItem")
			AddKeyInfo(3, "OrCustomer")

		endmethod
	
		;;; <summary>
		;;; Returns a new Order object containing data from a record and a GRFA.
		;;; The related data properties (REL_Vendor, REL_Customer, REL_Item, REL_TagCustomer and REL_TagVendor) will not be populated.
		;;; </summary>
		;;; <param name="dataArea">The record containing the data for the new Order object.</param>
		;;; <param name="grfa">The GRFA associated with the current state of the data.</param>
		;;; <returns></returns>
		public override method MakeNew, @DataObjectBase
			required in dataArea, a
			required in grfa, a
		proc
			mreturn new Order((strOrder)dataArea) { GlobalRFA = grfa }
		endmethod

		;;; <summary>
		;;; Returns a new Order object containing data from a record and a GRFA.
		;;; The related data properties (REL_Vendor, REL_Customer, REL_Item, REL_TagCustomer and REL_TagVendor) will be populated.
		;;; </summary>
		;;; <param name="dataArea">The record containing the data for the new Order object.</param>
		;;; <param name="grfa">The GRFA associated with the current state of the data.</param>
		;;; <param name="joinedObjects">Data to allow the related data properties (REL_Vendor, REL_Customer, REL_Item, REL_TagCustomer and REL_TagVendor) to be populated.</param>
		;;; <returns></returns>
		public override method MakeNew, @DataObjectBase
			required in dataArea, a
			required in grfa, a
			required in joinedObjects, [#]KeyValuePair<String, Object>
		proc
			data newOrder = new Order((strOrder)dataArea) { GlobalRFA = grfa }
			data joinedObject, KeyValuePair<String, Object>
			foreach joinedObject in joinedObjects
			begin
				using joinedObject.Key select
				("REL_Vendor"), 
					newOrder.REL_Vendor = (@Vendor)joinedObject.Value
				("REL_Customer"), 
					newOrder.REL_Customer = (@Customer)joinedObject.Value
				("REL_Item"), 
					newOrder.REL_Item = (@Plant)joinedObject.Value
				("REL_TagCustomer"),
					newOrder.REL_TagCustomer = (@Customer)joinedObject.Value
				("REL_TagVendor"),
					newOrder.REL_TagVendor = (@Vendor)joinedObject.Value
				endusing
			end

			mreturn newOrder

		endmethod

		;;; <summary>
		;;; 
		;;; </summary>
		;;; <param name=""></param>
		;;; <param name=""></param>
		;;; <returns></returns>
		public override method FormatKeyLiteral, a
			required in keyNumber, int
			required in parts, @Dictionary<String, Object>
			endparams
			stack record key0
				OrNumber, D6
			endrecord
			stack record key1
				OrVendor, D6
			endrecord
			stack record key2
				OrItem, D6
			endrecord
			stack record key3
				OrCustomer, D6
			endrecord
		proc
			using keyNumber select
			(0),
			begin
				data startPos = 1
				if(!KeyValueHelper(key0.OrNumber, "OrNumber", parts))
					mreturn key0(1:startPos - 1)
				mreturn key0
			end
			(1),
			begin
				data startPos = 1
				if(!KeyValueHelper(key1.OrVendor, "OrVendor", parts))
					mreturn key1(1:startPos - 1)
				mreturn key1
			end
			(2),
			begin
				data startPos = 1
				if(!KeyValueHelper(key2.OrItem, "OrItem", parts))
					mreturn key2(1:startPos - 1)
				mreturn key2
			end
			(3),
			begin
				data startPos = 1
				if(!KeyValueHelper(key3.OrCustomer, "OrCustomer", parts))
					mreturn key3(1:startPos - 1)
				mreturn key3
			end
			endusing

			throw new ApplicationException(String.Format("Invalid key number {0} encountered in OrderMetadata.FormatKeyLiteral",keyNumber))

		endmethod

	endclass

endnamespace

