<CODEGEN_FILENAME><StructureNoplural>.Serialization.dbl</CODEGEN_FILENAME>
<REQUIRES_CODEGEN_VERSION>5.4.6</REQUIRES_CODEGEN_VERSION>
;//****************************************************************************
;//
;// Title:       SystemTextJsonModel.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: Template to define structure based Data Object with CLR types
;//
;// Copyright (c) 2012, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
;; Title:       <StructureNoplural>.Serialization.dbl
;;
;; Description: Data model representing data defined by the repository
;;              structure <STRUCTURE_NOALIAS><IF STRUCTURE_FILES> and from the data file <FILE_NAME></IF STRUCTURE_FILES>.
;;
;;*****************************************************************************
;; WARNING: GENERATED CODE!
;; This file was generated by CodeGen. Avoid editing the file if possible.
;; Any changes you make will be lost of the file is re-generated.
;;*****************************************************************************

import System
import System.Collections.Generic
import System.Text.Json
import System.Text.Json.Serialization
import Harmony.Core
import System.Reflection

namespace <NAMESPACE>

    ;;put the converter on the target type using a partial class
    {JsonConverter(^typeof(<StructureNoplural>Converter))}
    public partial class <StructureNoplural> extends DataObjectBase

    endclass

    public class <StructureNoplural>Converter extends JsonConverter<<StructureNoplural>>
        public static MemberLookup, @Dictionary<string, PropertyInfo>

		static method <StructureNoplural>Converter
		proc
			MemberLookup = new Dictionary<String, PropertyInfo>()
			data publicProperties = ^typeof(T).GetProperties()
			data prop, @PropertyInfo
			foreach prop in publicProperties
			begin
				
				MemberLookup.Add(prop.Name, prop)
			end
		endmethod

        public override method Write, void
            writer, @Utf8JsonWriter
            objectValue, @<StructureNoplural>
            options, @JsonSerializerOptions
        proc
            writer.WriteStartObject()
<COUNTER_1_RESET>
<FIELD_LOOP>
  <IF USER>
  <ELSE>
      <IF HARMONYCORE_CUSTOM_FIELD OR DATE OR TIME>
            writer.WriteString("<FieldSqlname>", objectValue.<FieldSqlname>.ToString())
      <ELSE ALPHA OR CUSTOM_HARMONY_AS_STRING>
            writer.WriteString("<FieldSqlname>", objectValue.<FieldSqlname>)
      <ELSE DECIMAL OR INTEGER OR AUTO_SEQUENCE OR AUTO_TIMESTAMP>
            writer.WriteNumber("<FieldSqlname>", objectValue.<FieldSqlname>)
      <ELSE BOOLEAN>
            writer.WriteBoolean("<FieldSqlname>", objectValue.<FieldSqlname>)
      <ELSE>
            throw new NotImplementedException()
      </IF HARMONYCORE_CUSTOM_FIELD>
	</IF USER>
</FIELD_LOOP>
			writer.WriteEndObject()
		endmethod

       public override method Read, @<StructureNoplural>
			inout reader, Utf8JsonReader
			typeToConvert, @Type
			options, @JsonSerializerOptions 
		proc
			data resultObject = new <StructureNoplural>()
			data propType, @PropertyInfo
			
			while(reader.Read())
			begin
				using reader.TokenType select
				(JsonTokenType.Comment),
					nop
				(JsonTokenType.String),
					propType.SetValue(resultObject, reader.GetString())
				(JsonTokenType.None),
					nop
				(JsonTokenType.False),
					propType.SetValue(resultObject, false)
				(JsonTokenType.EndObject),
					mreturn resultObject
				(JsonTokenType.Number),
				begin
					if(propType.PropertyType == ^typeof(byte)) then
						propType.SetValue(resultObject, reader.GetByte())
					else if(propType.PropertyType == ^typeof(sbyte)) then
						propType.SetValue(resultObject, reader.GetSByte())
					else if(propType.PropertyType == ^typeof(short)) then
						propType.SetValue(resultObject, reader.GetInt16())
					else if(propType.PropertyType == ^typeof(ushort)) then
						propType.SetValue(resultObject, reader.GetUInt16())
					else if(propType.PropertyType == ^typeof(int)) then
						propType.SetValue(resultObject, reader.GetInt32())
					else if(propType.PropertyType == ^typeof(uint)) then
						propType.SetValue(resultObject, reader.GetUInt32())
					else if(propType.PropertyType == ^typeof(long)) then
						propType.SetValue(resultObject, reader.GetInt64())
					else if(propType.PropertyType == ^typeof(ulong)) then
						propType.SetValue(resultObject, reader.GetUInt64())
					else if(propType.PropertyType == ^typeof(decimal)) then
						propType.SetValue(resultObject, reader.GetDecimal())
					else if(propType.PropertyType == ^typeof(float)) then
						propType.SetValue(resultObject, reader.GetSingle())
					else if(propType.PropertyType == ^typeof(double)) then
						propType.SetValue(resultObject, reader.GetDouble())
					else
						throw new NotImplementedException()
				end
				(JsonTokenType.PropertyName),
				begin
					if(!MemberLookup.TryGetValue(reader.GetString(), propType))
						propType = ^null
				end

				(JsonTokenType.Null),
					propType.SetValue(resultObject, ^null)
				(JsonTokenType.StartObject),
					propType.SetValue(resultObject, JsonSerializer.Deserialize(reader, propType.PropertyType, options))
				(JsonTokenType.True),
					propType.SetValue(resultObject, true)
				(JsonTokenType.EndArray),
					throw new NotImplementedException()
				(JsonTokenType.StartArray),
					propType.SetValue(resultObject, JsonSerializer.Deserialize(reader, propType.PropertyType, options))
				(),
					nop
				endusing
			end 
		endmethod
    endclass

endnamespace
